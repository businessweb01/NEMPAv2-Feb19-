// const Skeleton = styled('div')(({ theme, height }) => ({
//   backgroundColor: theme.palette.action.hover,
//   borderRadius: theme.shape.borderRadius,
//   height,
//   content: '" "',
// }))


import * as React from 'react';
import { ReactRouterAppProvider } from '@toolpad/core/react-router';
import { Outlet } from 'react-router';
import { AppProvider } from '@toolpad/core/AppProvider';
import { DashboardLayout } from '@toolpad/core/DashboardLayout';
import { PageContainer } from '@toolpad/core/PageContainer';
import { createTheme } from '@mui/material/styles';
import Stack from '@mui/material/Stack';
import Typography from '@mui/material/Typography';

// Pages
import ClientInfo from './pages/DE_client_info';
import Loan from './pages/DE_Loan';
import Payment from './pages/DE_of_payment';

// MUI Icons
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b', // Teal green
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
});

const NAVIGATION = [
  {
    segment: 'dashboard',
    title: 'Dashboard',
    icon: <DashboardIcon />,
  },
  {
    segment: 'loans',
    title: 'Loans',
    icon: <AccountBalanceIcon />,
    children: [
      {
        segment: 'Pending',
        title: 'Pending Loans',
        icon: <PendingActionsIcon />,
      },
      {
        segment: 'OnGoing',
        title: 'On Going Loans',
        icon: <AssuredWorkloadIcon />,
      },
      {
        segment: 'Paid',
        title: 'Paid Loans',
        icon: <CreditScoreIcon />,
      },
    ],
  },
  {
    segment: 'integrations',
    title: 'Transaction History',
    icon: <ReceiptLongIcon />,
  },
];

function CustomAppTitle() {
  return (
    <Stack direction="row" alignItems="center" spacing={2}>
      <Typography variant="h6">Loan Application</Typography>
    </Stack>
  );
}

export default function DashboardLayoutBasic(props) {
  return (
    <ReactRouterAppProvider navigation={NAVIGATION} theme={theme}>
      <DashboardLayout
        slots={{
          appTitle: CustomAppTitle,
        }}
      >
        <Outlet />
      </DashboardLayout>
    </ReactRouterAppProvider>
  );
}
|

  {
    segment: 'dashboard',
    title: 'Dashboard',
    icon: <DashboardIcon />,
  },
  {
    segment: 'orders',
    title: 'Loans',
    icon: <AccountBalanceIcon />,
    children: [
      {
        segment: 'Pending',
        title: 'Pending Loans',
        icon: <PendingActionsIcon />,
        action: (
          <Chip
            label={5}
            color="warning"
            style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
          />
        ),
        route: '/orders/Pending', // Correct route for Pending Loans
        component: <ClientInfo />, // Rendering ClientInfo for Pending Loans
      },
      {
        segment: 'OnGoing',
        title: 'On Going Loans',
        icon: <AssuredWorkloadIcon />,
        action: (
          <Chip
            label={5}
            color="warning"
            style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
          />
        ),
        route: '/orders/OnGoing', // Correct route for On Going Loans
        component: <Loan />, // Rendering Loan component for On Going Loans
      },
      {
        segment: 'Paid',
        title: 'Paid Loans',
        icon: <CreditScoreIcon />,
        route: '/orders/Paid', // Correct route for Paid Loans
        component: <Payment />, // Rendering Payment component for Paid Loans
      },
    ],
  },
  {
    segment: 'integrations',
    title: 'Transaction History',
    icon: <ReceiptLongIcon />,
    route: '/integrations',
    component: <Payment />, // Placeholder for Transaction History page
  },

    toast.custom((t) => (
            <div
              className={`${
                t.visible ? 'animate-enter' : 'animate-leave'
              } max-w-md w-full bg-white shadow-xl rounded-lg pointer-events-auto flex flex-col p-4`}
            >
              {/* First Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Amount:
                </div>
                <div className="text-sm text-gray-600">{loanAmount}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Interest Per Month:
                </div>
                <div className="text-sm text-gray-600">{(loanAmount * (loanInterest / 100)).toFixed(2)}</div>
              </div>
          
              {/* Second Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  No. of Months:
                </div>
                <div className="text-sm text-gray-600">{noOfMonths}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Total Loan:
                </div>
                <div className="text-sm text-gray-600">{total}</div>
              </div>
          
              {/* Third Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Date:
                </div>
                <div className="text-sm text-gray-600">{new Date(loanDate).toLocaleDateString()}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Ref No.:
                </div>
                <div className="text-sm text-gray-600">{loanRefNo}</div>
              </div>
          
              {/* Close Button */}
              <div className="mt-4 flex justify-center">
                <button
                  onClick={() => toast.dismiss(t.id)}
                  className="px-4 py-2 text-sm font-medium text-indigo-600 bg-indigo-100 rounded-md hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  Close
                </button>
              </div>
            </div>
          ));

            React.useEffect(() => {
    if (activeStep === 2) {
      // Automatically reset after 3 seconds
      setTimeout(() => {
        handleReset();
      }, 1500);
    }
  }, [activeStep]);

  const express = require('express');
const multer = require('multer');
const mssql = require('mssql');
const WebSocket = require('ws');
const path = require('path');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: '../.env.development' }); // Load .env file
const jwtDecode = require('jwt-decode');
// Set up express app
const app = express();
const port = 5000;
const wss = new WebSocket.Server({ port: 8080 });
// Enable CORS
app.use(cors()); // Allow all origins
app.use(express.json());
// Multer Storage Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const { firstName, lastName } = req.body;
    const fileExtension = path.extname(file.originalname);
    cb(null, `${firstName}${lastName}(ValidID)${fileExtension}`);
  }
});

const upload = multer({ storage });

// MSSQL Configuration
const sqlConfig = {
  user: 'sa',
  password: 'Eugene12042001',
  server: 'LAPTOP-NI-POGI',
  database: 'NEMPA',
  options: {
    instanceName: "SQLEXPRESS",
    encrypt: false,
    trustServerCertificate: true,
  },
  connectionTimeout: 15000,
  requestTimeout: 15000,
};

// Create a connection pool once
let pool;

async function connectToDatabase() {
  if (!pool) {
    try {
      pool = await mssql.connect(sqlConfig);
      console.log('Connected to the database successfully');
    } catch (err) {
      console.error('Database connection failed:', err);
      process.exit(1); // Exit if connection fails
    }
  }
  return pool;
}

// ðŸ“Œ Middleware to parse form-data and handle file upload
app.post('/submit', upload.single('validId'), async (req, res) => {
  const { lastName, firstName, middleName, birthday, contactNumber, address, dataRegistered } = req.body;
  const validIdFileName = req.file ? req.file.filename : 'No file uploaded';

  try {
    const pool = await connectToDatabase();
    const currentYear = new Date().getFullYear();

    // Check if the client already exists based on fname, mname, and lname
    const existingClient = await pool.request()
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('lastName', mssql.NVarChar, lastName)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE fname = @firstName AND mname = @middleName AND lname = @lastName
      `);

    if (existingClient.recordset.length > 0) {
      // Client already exists, generate JWT token with existing clientId
      const clientId = existingClient.recordset[0].client_id;
      const token = jwt.sign(
        { clientId, firstName, lastName },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
      );

      return res.status(200).json({ message: 'Client already exists', clientId, token });
    }

    // Get the highest client_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE client_id LIKE CONCAT(@currentYear, '%')
        ORDER BY client_id DESC
      `);

    let clientId = `${currentYear}01`;

    if (result.recordset.length > 0) {
      const lastClientId = result.recordset[0].client_id;
      const newIdNumber = parseInt(lastClientId.slice(-2), 10) + 1;
      clientId = `${currentYear}${String(newIdNumber).padStart(2, '0')}`;
    }

    // Insert new client data if client does not exist
    await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('lastName', mssql.NVarChar, lastName)
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('birthday', mssql.NVarChar, birthday)
      .input('contactNumber', mssql.NVarChar, contactNumber)
      .input('address', mssql.NVarChar, address)
      .input('validIdFileName', mssql.NVarChar, validIdFileName)
      .input('dataRegistered', mssql.NVarChar, dataRegistered)
      .query(`
        INSERT INTO client_info (client_id, lname, fname, mname, bday, cont_num, address, valid_id, reg_date)
        VALUES (@clientId, @lastName, @firstName, @middleName, @birthday, @contactNumber, @address, @validIdFileName, @dataRegistered)
      `);

    // Generate JWT Token for new client
    const token = jwt.sign(
      { clientId, firstName, lastName },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    res.status(200).json({ message: 'Data inserted successfully!', clientId, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Error inserting data into the database.' });
  }
});



// The route to handle loan submissions
app.post('/submit-loan', async (req, res) => {
  // Destructure the required data from the request body
  const { clientId, loanAmount, loanInterest, noOfMonths, loanDate, total, biWeeklyAmortization } = req.body;

  try {
    // Log the request body to check if loanAmount has a value
    console.log('Request Body:', req.body);
    
    const pool = await mssql.connect(sqlConfig);

    // Generate loan reference number (loanRefNo) with the current year and incrementing number
    const currentYear = new Date().getFullYear();
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 LoanRefNo
        FROM Loans
        WHERE LoanRefNo LIKE '${currentYear}%'
        ORDER BY LoanRefNo DESC
      `);

    let loanRefNo = `${currentYear}0001`;  // Default to the first loan of the year

    if (result.recordset.length > 0) {
      const lastLoanRefNo = result.recordset[0].LoanRefNo; // Ensure correct column name (case-sensitive)
      
      if (lastLoanRefNo) {
        const newRefNo = parseInt(lastLoanRefNo.slice(-4)) + 1;
        loanRefNo = `${currentYear}${String(newRefNo).padStart(4, '0')}`;
      } else {
        console.error('No valid loanRefNo found');
        loanRefNo = `${currentYear}0001`; // Reset if the reference number is invalid
      }
    }
    const noOfTerms =  noOfMonths *2;
    const status = 'Waiting for Approval';
    const notReleased = 'No';
    // Insert the loan data into the loan table
    const resultInsert = await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('loanRefNo', mssql.NVarChar, loanRefNo)
      .input('loanAmount', mssql.Float, loanAmount)
      .input('loanInterest', mssql.Int, loanInterest)
      .input('noOfMonths', mssql.Int, noOfMonths)
      .input('loanDate', mssql.Date, loanDate)  // Insert the loan date
      .input('total', mssql.Float, total)
      .input('biWeeklyAmortization', mssql.Float, biWeeklyAmortization)
      .input('noOfTerms',mssql.Int, noOfTerms)
      .input('onGoing', mssql.NVarChar, status)
      .input('notReleased', mssql.NVarChar, notReleased)
      .query(`
        INSERT INTO Loans (LoanRefNo, client_id, LoanAmount, interest, noOfMonths, LoanDate, TotalAmount,biWeeklyPay,running_balance,no_of_terms,status,isReleased)
        VALUES (@loanRefNo, @clientId, @loanAmount, @loanInterest, @noOfMonths, @loanDate, @total, @biWeeklyAmortization, @total, @noOfTerms,@onGoing,@notReleased)
      `);

    // Return response with the token
    res.status(200).json({
      message: 'Loan data inserted successfully!',loanRefNo});
  } catch (err) {
    console.error('Error inserting loan data:', err);
    res.status(500).json({ message: 'Error inserting loan data.' });
  }
});




app.get('/loanData', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1]; // Assuming Bearer token format
  if (!token) {
    return res.status(400).send('Token missing');
  }

  const decodedToken = jwtDecode(token);
  const { loanRefNo, clientId } = decodedToken;
  const status = 'On Going';
  try {
    const pool = await mssql.connect(sqlConfig); // Ensure that sqlConfig is defined and correct
    const result = await pool.request() // Corrected query using pool.request()
      .input('loanRefNo', mssql.NVarChar, loanRefNo) // Use parameterized queries for security
      .input('clientId', mssql.NVarChar, clientId)
      .input('onGoing', mssql.NVarChar, status)
      .query(`
        SELECT LoanRefNo, client_id, LoanAmount, TotalAmount, noOfMonths, LoanDate, interest, biWeeklyPay,running_balance 
        FROM Loans 
        WHERE LoanRefNo = @loanRefNo AND client_id = @clientId AND status = @onGoing
      `);

    if (result.recordset.length > 0) {
      res.json(result.recordset[0]); // Send loan data back
    } else {
      res.status(404).send('Loan not found');
    }
  } catch (error) {
    console.error('Database query error', error);
    res.status(500).send('Internal server error');
  }
});


// Insert payment and update loan balance
app.post('/make-payment', async (req, res) => {
  const { loanRefNo, paymentDate, payment } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    // Get the current year
    const currentYear = new Date().getFullYear();

    // Query the latest PaymentID for the current year to get the last series number
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID
        FROM Payments
        WHERE PaymentID LIKE '${currentYear}%'
        ORDER BY PaymentID DESC
      `);

    // Generate the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastPaymentID = result.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }

    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, '0')}`;

    // Insert payment into Payments table
    await pool.request()
      .input('PaymentID', mssql.NVarChar, nextPaymentID)
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .input('PaymentDate', mssql.DateTime, paymentDate)
      .query(`
        INSERT INTO Payments (PaymentID, LoanRefNo, PaymentAmount, PaymentDate)
        VALUES (@PaymentID, @LoanRefNo, @PaymentAmount, @PaymentDate)
      `);

    // Update the loan balance by reducing it with the payment amount
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .query(`
        UPDATE Loans
        SET running_balance = running_balance - @PaymentAmount
        WHERE LoanRefNo = @LoanRefNo
      `);

    // Get the updated loan information to return
    const updatedLoan = await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .query(`
        SELECT running_balance, TotalAmount, biWeeklyPay
        FROM Loans
        WHERE LoanRefNo = @LoanRefNo
      `);

    const updatedData = updatedLoan.recordset[0];
    if (updatedData.running_balance <= 0) {
      await pool.request()
        .input('fullyPaid', mssql.NVarChar, 'Fully Paid')
        .input('LoanRefNo', mssql.Int, loanRefNo)
        .query(`
          UPDATE Loans
          SET status = @fullyPaid
          WHERE LoanRefNo = @LoanRefNo
        `);
    }
    res.status(200).json({
      updatedLoanAmount: updatedData.running_balance,
      updatedTotalAmount: updatedData.TotalAmount,
      updatedbiWeeklyAmount: updatedData.biWeeklyPay,
      message: 'Payment recorded and loan balance updated successfully.'
    });

  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ message: 'Error processing payment.' });
  }
});


app.get('/PendingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.LoanDate, l.LoanAmount, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status IN ('Waiting for Approval', 'Approved')
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      date: row.LoanDate,
      status: row.status,
      amount: row.LoanAmount,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.post('/submitLoanApprovals', async (req, res) => {
  const { loanId, approvedDate, approvers } = req.body; // approvers is an array

  if (!Array.isArray(approvers) || approvers.length === 0) {
    return res.status(400).json({ success: false, message: "Approvers list is empty or invalid." });
  }

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // Query the latest approved_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 approved_id
        FROM approvers
        WHERE approved_id LIKE '${currentYear}%'
        ORDER BY approved_id DESC
      `);

    // Determine the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastApprovedID = result.recordset[0].approved_id; // Correct column reference
      nextSeries = parseInt(lastApprovedID.slice(-6)) + 1;
    }

    // Insert each approver as a new row
    for (let i = 0; i < approvers.length; i++) {
      const nextApproverID = `${currentYear}${String(nextSeries + i).padStart(6, '0')}`;

      await pool.request()
        .input('ApprovedId', mssql.NVarChar, nextApproverID)
        .input('LoanRefNo', mssql.Int, loanId)
        .input('Date', mssql.Date, approvedDate)
        .input('Approver', mssql.NVarChar, approvers[i]) // Insert individual approver
        .query(`
          INSERT INTO approvers (approved_id, LoanRefNo, approvedDate, approver_name)
          VALUES (@ApprovedId, @LoanRefNo, @Date, @Approver)
        `);
    }

    // Update the status of the loan to "Approved"
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanId)
      .query(`
        UPDATE Loans
        SET status = 'Approved'
        WHERE LoanRefNo = @LoanRefNo
      `);

    res.status(200).json({ success: true, message: 'Loan approval submitted successfully.' });

  } catch (error) {
    console.error('Error processing loan approval:', error);
    return res.status(500).json({ success: false, message: 'Internal server error.' });
  }
});

app.get('/fetchApprovers/:loanId', async (req, res) => {
  const loanId = req.params.loanId;  // Get loanId from URL params

  try {
    // Query the database for approvers related to the loanId
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId) // Assuming loanId is an integer
      .query('SELECT approver_name FROM approvers WHERE LoanRefNo = @loanId');  // Your query to fetch approvers

    if (result.recordset.length > 0) {
      // If approvers are found, send them as the response
      res.json({
        success: true,
        approvers: result.recordset.map(row => ({
          name: row.approver_name,  // Assuming the column in the database is `approver_name`
        })),
      });
    }
  } catch (err) {
    console.error('Error fetching approvers:', err);
    res.status(500).json({ success: false, message: 'Error fetching approvers' });
  }
});

app.get('/pendingCount', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
    res.json({ count: result.recordset[0].count });
  } catch (error) {
    console.error('Error fetching pending loans:', error);
    res.status(500).send('Internal Server Error');
  }
});

const clients = new Set();
wss.on('connection', (ws) => {
  console.log('New client connected');
  clients.add(ws);

  // Function to send counts to all connected clients
  const sendLoanCounts = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query(`
        SELECT 
          (SELECT COUNT(*) FROM Loans WHERE status = 'Waiting for Approval') AS pendingCount,
          (SELECT COUNT(*) FROM Loans WHERE status = 'Released') AS releasedCount
      `);
      
      const counts = {
        type: 'loanCounts',
        pendingCount: result.recordset[0].pendingCount,
        releasedCount: result.recordset[0].releasedCount
      };

      // Broadcast to all connected clients
      clients.forEach(client => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify(counts));
        }
      });

    } catch (error) {
      console.error('Error fetching loan counts:', error);
    }
  };

  // Send initial data immediately when the client connects
  sendLoanCounts();

  // Set up an interval to update all clients every 10 seconds
  const intervalId = setInterval(sendLoanCounts, 10000);

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
    clients.delete(ws);
    if (clients.size === 0) {
      clearInterval(intervalId); // Stop the interval if no clients are connected
    }
  });
});

app.post('/releaseLoan', async (req, res) => {
  const { loanId, releasedBy, releasedDate , PaymentStartAt} = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    console.log('releasedBy:', releasedBy);
    // Update the loan status to Released and set other fields
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('releasedBy', mssql.NVarChar, releasedBy) 
      .input('releasedDate', mssql.Date, releasedDate)
      .input('PaymentStartAt', mssql.Date, PaymentStartAt)
      .query(`
        UPDATE Loans
        SET isReleased = 'Yes', status = 'Released', releasedBy = @releasedBy, releasedWhen = @releasedDate, PaymentStartAt = @PaymentStartAt
        WHERE LoanRefNo = @loanId
      `);

    res.status(200).json({ message: 'Loan Released successfully!' });

  } catch (err) {
    console.error('Error releasing loan:', err);
    res.status(500).json({ message: 'Error releasing loan.' });
  }
});

// Start the server
app.listen(port, async () => {
  await connectToDatabase(); // Ensure database is connected before accepting requests
  console.log(`Server running on port ${port}`);
});



const express = require('express');
const multer = require('multer');
const mssql = require('mssql');
const WebSocket = require('ws');
const path = require('path');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: '../.env.development' }); // Load .env file
const jwtDecode = require('jwt-decode');
// Set up express app
const app = express();
const port = 5000;
const wss = new WebSocket.Server({ port: 8080 });
// Enable CORS
app.use(cors()); // Allow all origins
app.use(express.json());
// Multer Storage Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const { firstName, lastName } = req.body;
    const fileExtension = path.extname(file.originalname);
    cb(null, `${firstName}${lastName}(ValidID)${fileExtension}`);
  }
});

const upload = multer({ storage });

// MSSQL Configuration
const sqlConfig = {
  user: 'sa',
  password: 'Eugene12042001',
  server: 'LAPTOP-NI-POGI',
  database: 'NEMPA',
  options: {
    instanceName: "SQLEXPRESS",
    encrypt: false,
    trustServerCertificate: true,
  },
  connectionTimeout: 15000,
  requestTimeout: 15000,
};

// Create a connection pool once
let pool;

async function connectToDatabase() {
  if (!pool) {
    try {
      pool = await mssql.connect(sqlConfig);
      console.log('Connected to the database successfully');
    } catch (err) {
      console.error('Database connection failed:', err);
      process.exit(1); // Exit if connection fails
    }
  }
  return pool;
}

// ðŸ“Œ Middleware to parse form-data and handle file upload
app.post('/submit', upload.single('validId'), async (req, res) => {
  const { lastName, firstName, middleName, birthday, contactNumber, address, dataRegistered } = req.body;
  const validIdFileName = req.file ? req.file.filename : 'No file uploaded';

  try {
    const pool = await connectToDatabase();
    const currentYear = new Date().getFullYear();

    // Check if the client already exists based on fname, mname, and lname
    const existingClient = await pool.request()
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('lastName', mssql.NVarChar, lastName)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE fname = @firstName AND mname = @middleName AND lname = @lastName
      `);

    if (existingClient.recordset.length > 0) {
      // Client already exists, generate JWT token with existing clientId
      const clientId = existingClient.recordset[0].client_id;
      const token = jwt.sign(
        { clientId, firstName, lastName },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
      );

      return res.status(200).json({ message: 'Client already exists', clientId, token });
    }

    // Get the highest client_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE client_id LIKE CONCAT(@currentYear, '%')
        ORDER BY client_id DESC
      `);

    let clientId = `${currentYear}01`;

    if (result.recordset.length > 0) {
      const lastClientId = result.recordset[0].client_id;
      const newIdNumber = parseInt(lastClientId.slice(-2), 10) + 1;
      clientId = `${currentYear}${String(newIdNumber).padStart(2, '0')}`;
    }

    // Insert new client data if client does not exist
    await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('lastName', mssql.NVarChar, lastName)
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('birthday', mssql.NVarChar, birthday)
      .input('contactNumber', mssql.NVarChar, contactNumber)
      .input('address', mssql.NVarChar, address)
      .input('validIdFileName', mssql.NVarChar, validIdFileName)
      .input('dataRegistered', mssql.NVarChar, dataRegistered)
      .query(`
        INSERT INTO client_info (client_id, lname, fname, mname, bday, cont_num, address, valid_id, reg_date)
        VALUES (@clientId, @lastName, @firstName, @middleName, @birthday, @contactNumber, @address, @validIdFileName, @dataRegistered)
      `);

    // Generate JWT Token for new client
    const token = jwt.sign(
      { clientId, firstName, lastName },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    res.status(200).json({ message: 'Data inserted successfully!', clientId, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Error inserting data into the database.' });
  }
});



// The route to handle loan submissions
app.post('/submit-loan', async (req, res) => {
  // Destructure the required data from the request body
  const { clientId, loanAmount, loanInterest, noOfMonths, loanDate, total, biWeeklyAmortization } = req.body;

  try {
    // Log the request body to check if loanAmount has a value
    console.log('Request Body:', req.body);
    
    const pool = await mssql.connect(sqlConfig);

    // Generate loan reference number (loanRefNo) with the current year and incrementing number
    const currentYear = new Date().getFullYear();
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 LoanRefNo
        FROM Loans
        WHERE LoanRefNo LIKE '${currentYear}%'
        ORDER BY LoanRefNo DESC
      `);

    let loanRefNo = `${currentYear}0001`;  // Default to the first loan of the year

    if (result.recordset.length > 0) {
      const lastLoanRefNo = result.recordset[0].LoanRefNo; // Ensure correct column name (case-sensitive)
      
      if (lastLoanRefNo) {
        const newRefNo = parseInt(lastLoanRefNo.slice(-4)) + 1;
        loanRefNo = `${currentYear}${String(newRefNo).padStart(4, '0')}`;
      } else {
        console.error('No valid loanRefNo found');
        loanRefNo = `${currentYear}0001`; // Reset if the reference number is invalid
      }
    }
    const noOfTerms =  noOfMonths *2;
    const status = 'Waiting for Approval';
    const notReleased = 'No';
    // Insert the loan data into the loan table
    const resultInsert = await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('loanRefNo', mssql.NVarChar, loanRefNo)
      .input('loanAmount', mssql.Float, loanAmount)
      .input('loanInterest', mssql.Int, loanInterest)
      .input('noOfMonths', mssql.Int, noOfMonths)
      .input('loanDate', mssql.Date, loanDate)  // Insert the loan date
      .input('total', mssql.Float, total)
      .input('biWeeklyAmortization', mssql.Float, biWeeklyAmortization)
      .input('noOfTerms',mssql.Int, noOfTerms)
      .input('onGoing', mssql.NVarChar, status)
      .input('notReleased', mssql.NVarChar, notReleased)
      .query(`
        INSERT INTO Loans (LoanRefNo, client_id, LoanAmount, interest, noOfMonths, LoanDate, TotalAmount,biWeeklyPay,running_balance,no_of_terms,status,isReleased)
        VALUES (@loanRefNo, @clientId, @loanAmount, @loanInterest, @noOfMonths, @loanDate, @total, @biWeeklyAmortization, @total, @noOfTerms,@onGoing,@notReleased)
      `);

    // Return response with the token
    res.status(200).json({
      message: 'Loan data inserted successfully!',loanRefNo});
  } catch (err) {
    console.error('Error inserting loan data:', err);
    res.status(500).json({ message: 'Error inserting loan data.' });
  }
});




app.get('/loanData', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1]; // Assuming Bearer token format
  if (!token) {
    return res.status(400).send('Token missing');
  }

  const decodedToken = jwtDecode(token);
  const { loanRefNo, clientId } = decodedToken;
  const status = 'On Going';
  try {
    const pool = await mssql.connect(sqlConfig); // Ensure that sqlConfig is defined and correct
    const result = await pool.request() // Corrected query using pool.request()
      .input('loanRefNo', mssql.NVarChar, loanRefNo) // Use parameterized queries for security
      .input('clientId', mssql.NVarChar, clientId)
      .input('onGoing', mssql.NVarChar, status)
      .query(`
        SELECT LoanRefNo, client_id, LoanAmount, TotalAmount, noOfMonths, LoanDate, interest, biWeeklyPay,running_balance 
        FROM Loans 
        WHERE LoanRefNo = @loanRefNo AND client_id = @clientId AND status = @onGoing
      `);

    if (result.recordset.length > 0) {
      res.json(result.recordset[0]); // Send loan data back
    } else {
      res.status(404).send('Loan not found');
    }
  } catch (error) {
    console.error('Database query error', error);
    res.status(500).send('Internal server error');
  }
});


// Insert payment and update loan balance
app.post('/make-payment', async (req, res) => {
  const { loanRefNo, paymentDate, payment } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    // Get the current year
    const currentYear = new Date().getFullYear();

    // Query the latest PaymentID for the current year to get the last series number
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID
        FROM Payments
        WHERE PaymentID LIKE '${currentYear}%'
        ORDER BY PaymentID DESC
      `);

    // Generate the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastPaymentID = result.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }

    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, '0')}`;

    // Insert payment into Payments table
    await pool.request()
      .input('PaymentID', mssql.NVarChar, nextPaymentID)
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .input('PaymentDate', mssql.DateTime, paymentDate)
      .query(`
        INSERT INTO Payments (PaymentID, LoanRefNo, PaymentAmount, PaymentDate)
        VALUES (@PaymentID, @LoanRefNo, @PaymentAmount, @PaymentDate)
      `);

    // Update the loan balance by reducing it with the payment amount
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .query(`
        UPDATE Loans
        SET running_balance = running_balance - @PaymentAmount
        WHERE LoanRefNo = @LoanRefNo
      `);

    // Get the updated loan information to return
    const updatedLoan = await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .query(`
        SELECT running_balance, TotalAmount, biWeeklyPay
        FROM Loans
        WHERE LoanRefNo = @LoanRefNo
      `);

    const updatedData = updatedLoan.recordset[0];
    if (updatedData.running_balance <= 0) {
      await pool.request()
        .input('fullyPaid', mssql.NVarChar, 'Fully Paid')
        .input('LoanRefNo', mssql.Int, loanRefNo)
        .query(`
          UPDATE Loans
          SET status = @fullyPaid
          WHERE LoanRefNo = @LoanRefNo
        `);
    }
    res.status(200).json({
      updatedLoanAmount: updatedData.running_balance,
      updatedTotalAmount: updatedData.TotalAmount,
      updatedbiWeeklyAmount: updatedData.biWeeklyPay,
      message: 'Payment recorded and loan balance updated successfully.'
    });

  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ message: 'Error processing payment.' });
  }
});


app.get('/PendingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.LoanDate, l.LoanAmount, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status IN ('Waiting for Approval', 'Approved')
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      date: row.LoanDate,
      status: row.status,
      amount: row.LoanAmount,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.post('/submitLoanApprovals', async (req, res) => {
  const { loanId, approvedDate, approvers } = req.body; // approvers is an array

  if (!Array.isArray(approvers) || approvers.length === 0) {
    return res.status(400).json({ success: false, message: "Approvers list is empty or invalid." });
  }

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // Query the latest approved_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 approved_id
        FROM approvers
        WHERE approved_id LIKE '${currentYear}%'
        ORDER BY approved_id DESC
      `);

    // Determine the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastApprovedID = result.recordset[0].approved_id; // Correct column reference
      nextSeries = parseInt(lastApprovedID.slice(-6)) + 1;
    }

    // Insert each approver as a new row
    for (let i = 0; i < approvers.length; i++) {
      const nextApproverID = `${currentYear}${String(nextSeries + i).padStart(6, '0')}`;

      await pool.request()
        .input('ApprovedId', mssql.NVarChar, nextApproverID)
        .input('LoanRefNo', mssql.Int, loanId)
        .input('Date', mssql.Date, approvedDate)
        .input('Approver', mssql.NVarChar, approvers[i]) // Insert individual approver
        .query(`
          INSERT INTO approvers (approved_id, LoanRefNo, approvedDate, approver_name)
          VALUES (@ApprovedId, @LoanRefNo, @Date, @Approver)
        `);
    }

    // Update the status of the loan to "Approved"
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanId)
      .query(`
        UPDATE Loans
        SET status = 'Approved'
        WHERE LoanRefNo = @LoanRefNo
      `);

    res.status(200).json({ success: true, message: 'Loan approval submitted successfully.' });

  } catch (error) {
    console.error('Error processing loan approval:', error);
    return res.status(500).json({ success: false, message: 'Internal server error.' });
  }
});

app.get('/fetchApprovers/:loanId', async (req, res) => {
  const loanId = req.params.loanId;  // Get loanId from URL params

  try {
    // Query the database for approvers related to the loanId
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId) // Assuming loanId is an integer
      .query('SELECT approver_name FROM approvers WHERE LoanRefNo = @loanId');  // Your query to fetch approvers

    if (result.recordset.length > 0) {
      // If approvers are found, send them as the response
      res.json({
        success: true,
        approvers: result.recordset.map(row => ({
          name: row.approver_name,  // Assuming the column in the database is `approver_name`
        })),
      });
    }
  } catch (err) {
    console.error('Error fetching approvers:', err);
    res.status(500).json({ success: false, message: 'Error fetching approvers' });
  }
});

wss.on('connection', (ws) => {
  console.log('New client connected');

  // Send initial pending count
  const sendPendingCount = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
      ws.send(JSON.stringify({ type: 'pendingCount', count: result.recordset[0].count }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  };

  sendPendingCount();  // Send initial data when the client connects

  // Simulate the pending loans count update every 10 seconds
  setInterval(async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
      const pendingCount = result.recordset[0].count;

      // Send the updated count to the client
      ws.send(JSON.stringify({ type: 'pendingCount', count: pendingCount }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  }, 10000);  // Update every 10 seconds

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

wss.on('connection', (ws) => {
  console.log('New client connected');

  // Send initial pending count
  const sendPendingCount = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Released'");
      ws.send(JSON.stringify({ type: 'pendingCount', count: result.recordset[0].count }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  };

  sendPendingCount();  // Send initial data when the client connects

  // Simulate the pending loans count update every 10 seconds
  setInterval(async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Released'");
      const releasedCount = result.recordset[0].count;

      // Send the updated count to the client
      ws.send(JSON.stringify({ type: 'releasedCount', count: releasedCount }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  }, 10000);  // Update every 10 seconds

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

app.post('/releaseLoan', async (req, res) => {
  const { loanId, releasedBy, releasedDate, PaymentStartAt } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    console.log('releasedBy:', releasedBy);
    // Update the loan status to Released and set other fields
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('releasedBy', mssql.NVarChar, releasedBy) 
      .input('releasedDate', mssql.Date, releasedDate)
      .input('PaymentStartAt', mssql.Date, PaymentStartAt)
      .query(`
        UPDATE Loans
        SET isReleased = 'Yes', status = 'Released', releasedBy = @releasedBy, releasedWhen = @releasedDate, PaymentStartAt = @PaymentStartAt
        WHERE LoanRefNo = @loanId
      `);

    res.status(200).json({ message: 'Loan Released successfully!' });

  } catch (err) {
    console.error('Error releasing loan:', err);
    res.status(500).json({ message: 'Error releasing loan.' });
  }
});

app.get('/OnGoingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.biWeeklyPay, l.running_balance, l.PaymentStartAt, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status = 'Released'
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      dueDate: row.PaymentStartAt,
      biWeeklyPay: row.biWeeklyPay,
      amount: row.running_balance,
      status: row.status,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

// Start the server
app.listen(port, async () => {
  await connectToDatabase(); // Ensure database is connected before accepting requests
  console.log(`Server running on port ${port}`);
});


import * as React from 'react';
import AddCardIcon from '@mui/icons-material/AddCard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import { AppProvider } from '@toolpad/core/AppProvider';
import { DashboardLayout } from '@toolpad/core/DashboardLayout';
import { PageContainer } from '@toolpad/core/PageContainer';
import Grid from '@mui/material/Grid2';
import Stack from '@mui/material/Stack';
import Chip from '@mui/material/Chip';
import Typography from '@mui/material/Typography';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { useDemoRouter } from '@toolpad/core/internal';
import { useState, useEffect, useRef } from 'react';
// Pages
import Loan from './Checkout';
import PendingLoan from './PendingLoans';
import OnGoingLoan from './OnGoing';
import Dashboard from './Dashboard';
// Theme setup
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b', // Teal green
    },
    background: {
      paper: '#ffffff',
    },
  },
});

const DashboardLayoutBasic = () => {
  const [pendingLoansCount, setPendingLoansCount] = useState(0);
  const router = useDemoRouter('/dashboard');
  const [releasedLoansCount, setReleasedLoansCount] = useState(0);
  const wsRef = useRef(null);
  const reconnectAttempts = useRef(0);

  useEffect(() => {
    const connectWebSocket = () => {
      if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) {
        return; // Prevent duplicate connections
      }

      wsRef.current = new WebSocket("ws://localhost:8080");

      wsRef.current.onopen = () => {
        console.log("WebSocket connected");
        reconnectAttempts.current = 0; // Reset reconnect attempts
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === "loanCounts") {
            setPendingLoansCount(data.pendingCount);
            setReleasedLoansCount(data.releasedCount);
          }
        } catch (error) {
          console.error("Error parsing WebSocket message:", error);
        }
      };

      // wsRef.current.onerror = (error) => {
      //   console.error("WebSocket error:", error);
      // };

      wsRef.current.onclose = () => {
        console.log("WebSocket disconnected, attempting to reconnect...");

        if (reconnectAttempts.current < 5) { // Limit reconnection attempts
          reconnectAttempts.current += 1;
          setTimeout(connectWebSocket, 5000); // ðŸ”„ Retry after 5 seconds
        } else {
          console.error("Max reconnect attempts reached. WebSocket stopped.");
        }
      };
    };

    connectWebSocket();

    return () => wsRef.current && wsRef.current.close();
  }, []);


  // Function to render the correct page based on pathname
  function renderPage() {
    const { pathname } = router;
    switch (pathname) {
      case '/dashboard':
        return <Dashboard />;
      case '/loanApplication':
        return <Loan />;
      case '/loans/Pending':
        return <PendingLoan />;
      case '/loans/OnGoing':
        return <OnGoingLoan/>;
      default:
        return <Dashboard />;
    }
  }

  // Navigation setup
  const NAVIGATION = [
    {
      segment: 'dashboard',
      title: 'Dashboard',
      icon: <DashboardIcon />,
      component: <Dashboard />,
    },
    {
      segment: 'loans',
      title: 'Loans',
      icon: <AccountBalanceIcon />,
      children: [
        {
          segment: 'Pending',
          title: 'Pending Loans',
          icon: <PendingActionsIcon />,
          action: (
            <Chip
              label={pendingLoansCount}
              color="warning"
              style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
            />
          ),
          route: '/loans/Pending',
          component: <PendingLoan />,
        },
        {
          segment: 'OnGoing',
          title: 'On Going Loans',
          icon: <AssuredWorkloadIcon />,
          action: (
            <Chip
              label={releasedLoansCount}
              color="warning"
              style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
            />
          ),
          route: '/loans/OnGoing',
          component: <OnGoingLoan />,
        },
        {
          segment: 'Paid',
          title: 'Paid Loans',
          icon: <CreditScoreIcon />,
          route: '/loans/Paid',
        },
      ],
    },
    {
      segment: 'loanApplication',
      title: 'Loan Application',
      icon: <AddCardIcon />,
      route: '/loanApplication',
      component: <Loan />,
    },
    {
      segment: 'transactionhistory',
      title: 'Transaction History',
      icon: <ReceiptLongIcon />,
      route: '/integrations',
    },
  ];

  // Custom header for the app title
  function CustomAppTitle() {
    return (
      <Stack direction="row" alignItems="center" spacing={2}>
        <Typography variant="h6">Loan Application</Typography>
      </Stack>
    );
  }

  return (
    <AppProvider navigation={NAVIGATION} router={router} theme={theme}>
      <DashboardLayout
      disableCollapsibleSidebar
        slots={{
          appTitle: CustomAppTitle,
        }}
      >
        <PageContainer sx={{ paddingTop: 1, paddingBottom: 3 }}>
              {renderPage()}
        </PageContainer>
      </DashboardLayout>
    </AppProvider>
  );
};

export default DashboardLayoutBasic;




import React, { useEffect, useState, useCallback } from 'react';
import { Box, Table, Typography, List, ListItem, Sheet, useTheme, Input } from '@mui/joy';
import useMediaQuery from '@mui/material/useMediaQuery';

const LoanDetails = () => {
    const [loanData, setLoanData] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    useEffect(() => {
        async function fetchLoanDetails() {
            try {
                const response = await fetch('http://localhost:5000/fetch-all-loan-details');
                const data = await response.json();
                setLoanData(data);
                console.log(data); // For debugging purposes
            } catch (error) {
                console.error('Error fetching loan details:', error);
            }
        }

        fetchLoanDetails();
    }, []);

    const filteredLoanData = useCallback(() => {
        return loanData.filter(loan =>
            loan.LoanRefNo.toLowerCase().includes(searchTerm.toLowerCase()) ||
            loan.ReleasedBy.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [loanData, searchTerm]);

    const renderMobileView = useCallback(() => (
        <>
            <Box sx={{ mb: 2 }}>
                <Input
                    placeholder="Search by reference number or released by..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    fullWidth
                    variant="outlined"
                    sx={{
                        borderRadius: '8px',
                        mb: 3,
                        bgcolor: 'background.level1',
                        '& input': { p: 1 },
                    }}
                />
            </Box>
            <List sx={{ p: 0 }}>
                {filteredLoanData().length > 0 ? (
                    filteredLoanData().flatMap(loan =>
                        loan.Payments.map((payment, index) => (
                            <ListItem
                                key={`${loan.LoanRefNo}-${index}`}
                                sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    gap: 2,
                                    mb: 3,
                                    bgcolor: 'background.level2',
                                    borderRadius: 'md',
                                    p: 3,
                                    boxShadow: 2,
                                }}
                            >
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Reference No:</Typography>
                                    <Typography>{loan.LoanRefNo}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Payment Amount:</Typography>
                                    <Typography>â‚±{payment.PaymentAmount?.toLocaleString()}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Payment Date:</Typography>
                                    <Typography>{payment.PaymentDate}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Status:</Typography>
                                    <Typography>{loan.Status === 'Released' ? 'On Going' : loan.Status}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Released By:</Typography>
                                    <Typography>{loan.ReleasedBy}</Typography>
                                </Box>
                            </ListItem>
                        ))
                    )
                ) : (
                    <Typography textAlign="center" sx={{ color: 'text.tertiary' }}>No transactions found</Typography>
                )}
            </List>
        </>
    ), [loanData, searchTerm]);

    const renderDesktopView = useCallback(() => (
        <>
            <Box sx={{ mb: 2 }}>
                <Input
                    placeholder="Search by reference number or released by..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    fullWidth
                    variant="outlined"
                    sx={{
                        borderRadius: '8px',
                        mb: 3,
                        bgcolor: 'background.level1',
                        '& input': { p: 1 },
                    }}
                />
            </Box>
            <Table sx={{ borderCollapse: 'separate', borderSpacing: 2 }}>
                <thead style={{ backgroundColor: "#212529" }}>
                    <tr>
                        {[
                            "Reference Number",
                            "Loan Amount",
                            "Interest Rate", 
                            "Total Amount Paid",
                            "Client Name",
                            "Payment Status",
                            "Date"
                        ].map((header, index) => (
                            <th
                                key={index}
                                style={{
                                    padding: "12px 16px",
                                    color: "white",
                                    backgroundColor: "#212529",
                                    textAlign: "center"
                                }}
                            >
                                <Typography
                                    variant="body-sm"
                                    sx={{
                                        textAlign: "center",
                                        display: "block",
                                        color: "inherit"
                                    }}
                                >
                                    {header}
                                </Typography>
                            </th>
                        ))}
                    </tr>
                </thead>
                <tbody>
                    {filteredLoanData().length > 0 ? (
                        filteredLoanData().map(loan => (
                            loan.Payments.map((payment, index) => (
                                <tr key={`${loan.LoanRefNo}-${index}`}>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{loan.LoanRefNo}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>â‚±{payment.PaymentAmount?.toLocaleString()}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>1%</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>â‚±{loan.TotalAmountPaid?.toLocaleString()}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{loan.ReleasedBy}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>
                                        {loan.Status === 'Released' ? 'On Going' : loan.Status}
                                    </td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{payment.PaymentDate}</td>
                                </tr>
                            ))
                        ))
                    ) : (
                        <tr>
                            <td colSpan={7} style={{ textAlign: 'center', padding: '16px' }}>
                                <Typography sx={{ color: 'text.tertiary' }}>No transactions found</Typography>
                            </td>
                        </tr>
                    )}
                </tbody>
            </Table>
        </>
    ), [loanData, searchTerm, theme]);

    return (
        <Box sx={{ p: { xs: 2, sm: 4 }, bgcolor: 'background.default' }}>
            <Typography level="h4" sx={{ mb: 4, fontWeight: 'bold' }}>Transaction History</Typography>
            {isMobile ? renderMobileView() : renderDesktopView()}
        </Box>
    );
};

export default LoanDetails;


  const response = await fetch("http://localhost:5000/PayRecomputedLoan", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ loanId, recomputedAmount, recomputeInterestValue, recomputeDate, dateNow, status, balance, startOfPayment})
      });
      const data = await response.json();
      if(response.ok){
        toast.success(data.message || "Recomputed successfully!", { autoClose: 2000, containerId: 'main-toast' });
        fetchLoans();
      }else{
        toast.error(data.message || "An error occurred while recomputing.", { autoClose: 2000, containerId: 'main-toast' });
      }




      import * as React from 'react';
import AddCardIcon from '@mui/icons-material/AddCard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import MenuIcon from '@mui/icons-material/Menu';
import LogoutRoundedIcon from '@mui/icons-material/LogoutRounded';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import Slide from '@mui/material/Slide';
import { 
  Box, 
  Drawer, 
  List, 
  ListItemIcon, 
  ListItemText, 
  ListItemButton, 
  Collapse, 
  AppBar, 
  Toolbar, 
  Typography, 
  CssBaseline, 
  IconButton, 
  useMediaQuery,
  Chip,
} from '@mui/material';
import { styled, useTheme } from '@mui/material/styles';
import { useState, useEffect, useRef } from 'react';
import ExpandLess from '@mui/icons-material/ExpandLess';
import ExpandMore from '@mui/icons-material/ExpandMore';
import Neeco from '../public/NeecoLogo.svg';
import { createTheme, ThemeProvider } from '@mui/material/styles';

// Pages
import Loan from './Checkout';
import PendingLoan from './PendingLoans';
import OnGoingLoan from './OnGoing';
import Dashboard from './Dashboard';
import PaidLoans from './PaidLoans';
import TransactionHistory from './TransactHistory';
const drawerWidth = 280;

const Main = styled('main', { shouldForwardProp: (prop) => prop !== 'open' })( 
  ({ theme }) => ({
    flexGrow: 1,
    padding: theme.spacing(3),
  })
);

const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="up" ref={ref} {...props} />;
});

const [open, setOpen] = React.useState(false);

const handleClickOpen = () => {
  setOpen(true);
};

const handleClose = () => {
  setOpen(false);
};

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b',
    },
    background: {
      paper: '#ffffff',
    },
  },
});
const name = "Eugene Van Linsangan";
const email = "vaneugene01@gmail.com";
const DashboardLayoutBasic = () => {
  const [pendingLoansCount, setPendingLoansCount] = useState(0);
  const [releasedLoansCount, setReleasedLoansCount] = useState(0);
  const [currentPath, setCurrentPath] = useState('/dashboard');
  const [loansOpen, setLoansOpen] = useState(false);
  const [mobileOpen, setMobileOpen] = useState(false);
  const wsRef = useRef(null);
  const reconnectAttempts = useRef(0);

  const muiTheme = useTheme();
  const isMobile = useMediaQuery(muiTheme.breakpoints.down('sm'));

  useEffect(() => {
    const connectWebSocket = () => {
      if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) return;

      wsRef.current = new WebSocket("ws://localhost:8080");

      wsRef.current.onopen = () => {
        console.log("WebSocket connected");
        reconnectAttempts.current = 0;
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === "loanCounts") {
            setPendingLoansCount(data.pendingCount);
            setReleasedLoansCount(data.releasedCount);
          }
        } catch (error) {
          console.error("Error parsing WebSocket message:", error);
        }
      };

      wsRef.current.onclose = () => {
        console.log("WebSocket disconnected, attempting to reconnect...");
        if (reconnectAttempts.current < 5) {
          reconnectAttempts.current += 1;
          setTimeout(connectWebSocket, 5000);
        } else {
          console.error("Max reconnect attempts reached. WebSocket stopped.");
        }
      };
    };

    connectWebSocket();
    return () => wsRef.current && wsRef.current.close();
  }, []);

  const handleNavigation = (path) => {
    setCurrentPath(path);
    if (isMobile) {
      setMobileOpen(false);
    }
  };

  const handleLoansClick = () => {
    setLoansOpen(!loansOpen);
  };

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const PAGE_COMPONENTS = {
    '/dashboard': <Dashboard />,
    '/loanApplication': <Loan />,
    '/loans/Pending': <PendingLoan />,
    '/loans/OnGoing': <OnGoingLoan />,
    '/loans/Paid': <PaidLoans />,
    '/transactionhistory': <TransactionHistory />,
  };

  const currentPage = PAGE_COMPONENTS[currentPath] || <Dashboard />;

  const drawerContent = (
    <Box sx={{ 
      overflow: 'auto',
      display: 'flex',
      flexDirection: 'column',
      height: '100%',
      backgroundColor: '#EFEFF6',
      padding: '10px',
    }}>
      <List
      sx={{
        marginTop: '10px',
        backgroundColor: '#FCFCFF',
        borderRadius: '10px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        background: 'linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%)',
        padding: '10px',
      }}
      >
        {/* Dashboard Item */}
        <ListItemButton
          onClick={() => handleNavigation('/dashboard')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',  // Reduced padding
            fontSize: '0.8em',  // Smaller font size
            '&:hover': {
              backgroundColor: '#b2dfdb',
            },
            backgroundColor: currentPath === '/dashboard' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <DashboardIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Dashboard" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
  
        {/* Loans Item */}
        <ListItemButton
          onClick={handleLoansClick}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',  // Reduced padding
            fontSize: '0.8em',  // Smaller font size
            '&:hover': {
              backgroundColor: '#b2dfdb',
            },
            backgroundColor: ['/loans/Pending', '/loans/OnGoing', '/loans/Paid'].includes(currentPath) ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <AccountBalanceIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Loans" sx={{ fontSize: '0.8em' }} />
          {loansOpen ? <ExpandLess /> : <ExpandMore />}
        </ListItemButton>
  
        {/* Loans Collapse Items */}
        <Collapse in={loansOpen} timeout="auto" unmountOnExit>
          <List component="div" disablePadding>
            {/* Pending Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/Pending' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }}
              onClick={() => handleNavigation('/loans/Pending')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <PendingActionsIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="Pending Loans" sx={{ fontSize: '0.8em' }} />
              <Chip label={pendingLoansCount} sx={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold', fontSize: '0.75em' }} />
            </ListItemButton>
  
            {/* On Going Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/OnGoing' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }} 
              onClick={() => handleNavigation('/loans/OnGoing')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <AssuredWorkloadIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="On Going Loans" sx={{ fontSize: '0.8em' }} />
              <Chip label={releasedLoansCount} sx={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold', fontSize: '0.75em' }} />
            </ListItemButton>
  
            {/* Paid Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/Paid' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }}
              onClick={() => handleNavigation('/loans/Paid')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <CreditScoreIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="Paid Loans" sx={{ fontSize: '0.8em' }} />
            </ListItemButton>
          </List>
        </Collapse>
  
        {/* Other Items */}
        <ListItemButton 
          onClick={() => handleNavigation('/loanApplication')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',
            fontSize: '0.8em',
            '&:hover': { backgroundColor: '#b2dfdb' },
            backgroundColor: currentPath === '/loanApplication' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <AddCardIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Loan Application" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
  
        <ListItemButton 
          onClick={() => handleNavigation('/transactionhistory')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',
            fontSize: '0.8em',
            '&:hover': { backgroundColor: '#b2dfdb' },
            backgroundColor: currentPath === '/transactionhistory' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <ReceiptLongIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Transaction History" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
      </List>
      <Box sx={{ display: 'flex', gap: 2, mt: 'auto', flexDirection: 'column' }}>
        <TextField id="outlined-basic" label="Available Balance" variant="outlined" size="small" />
        <TextField id="outlined-basic" label="Used Balance" variant="outlined" size="small" />
      <Box sx={{ display: 'flex', justifyContent: 'center' }}>
        <Button variant="contained" color="primary" size="small" onClick={handleClickOpen}>
           Update Balance
        </Button>
        <Dialog
        open={open}
        TransitionComponent={Transition}
        keepMounted
        onClose={handleClose}
        aria-describedby="alert-dialog-slide-description"
      >
        <DialogTitle>{"Use Google's location service?"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-slide-description">
            Let Google help apps determine location. This means sending anonymous
            location data to Google, even when no apps are running.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Disagree</Button>
          <Button onClick={handleClose}>Agree</Button>
        </DialogActions>
      </Dialog>
      </Box>
      </Box>
      <Box sx={{ mt: 'auto', mb: 2 }}>
        <Box
          sx={{
            borderRadius: '12px',
            padding: '16px',
            backgroundColor: '#FCFCFF',
            boxShadow: '0 4px 8px rgba(0,0,0,0.08)',
            transition: 'all 0.2s ease-in-out',
            display: 'flex',
            alignItems: 'center', // Aligns content horizontally
            gap: 2,
            justifyContent: 'space-between',
          }}
        >
          <Box>
            <Typography
              variant="subtitle1"
              sx={{
                fontSize: '0.8rem',
                fontWeight: 600,
                color: '#2c3e50',
              }}
            >
              {name}
            </Typography>
            <Typography
              variant="body2"
              sx={{
                opacity: 0.7,
                fontSize: '0.8rem',
                fontWeight: 500,
              }}
            >
              {email}
            </Typography>
          </Box>
          <Box>
            <LogoutRoundedIcon sx={{ color: '#d90429', fontSize: '1.5rem' }} />
          </Box>
        </Box>
      </Box>

    </Box>
  );
  

  return (
    <ThemeProvider theme={theme}>
      <Box sx={{ display: 'flex' }}>
        <CssBaseline />
        <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
          <Toolbar>
            {isMobile && (
              <IconButton edge="start" color="inherit" onClick={handleDrawerToggle} sx={{ mr: 2 }}>
                <MenuIcon />
              </IconButton>
            )}
            <Typography variant="h6" noWrap component="div" sx={{ display: 'flex', alignItems: 'center', fontWeight: 'bold' }}>
              <img src={Neeco} alt="Neeco Logo" style={{ width: '30px', height: 'auto', marginRight: '10px' }} />
               NEECO II AREA 1
            </Typography>
          </Toolbar>
        </AppBar>

        <Drawer
          variant={isMobile ? "temporary" : "permanent"}
          open={isMobile ? mobileOpen : true}
          onClose={handleDrawerToggle}
          sx={{
            width: drawerWidth,
            flexShrink: 0,
            '& .MuiDrawer-paper': { width: drawerWidth, boxSizing: 'border-box' },
          }}
        >
          <Toolbar />
          {drawerContent}
        </Drawer>

        <Main
          sx={{
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            width: '100%', // Makes sure it takes full width
            padding: (theme) => theme.spacing(3),
            scrollbarWidth: 'none',
          }}
        >
          <Toolbar />
          <Box
            sx={{
              width: '100%',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              flexGrow: 1,
            }}
          >
            {currentPage}
          </Box>
        </Main>
      </Box>
    </ThemeProvider>
  );
};

export default DashboardLayoutBasic;

For Dynamic connection
const urlApi = import.meta.env.VITE_API_URL;
      const response = await fetch(`${urlApi}
the Whole Backend config
const express = require('express');
const multer = require('multer');
const mssql = require('mssql');
const WebSocket = require('ws');
const path = require('path');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: '../.env.development' }); // Load .env file
const jwtDecode = require('jwt-decode');
const bcrypt = require('bcryptjs'); 
// Set up express app
const app = express();
const port = 5000;
const wss = new WebSocket.Server({ port: 8080 }, () => {
  console.log("WebSocket Server started on ws://localhost:8080");
});

const clients = new Set(); // Store connected clients
// Enable CORS
app.use(cors()); // Allow all origins
app.use(express.json());
// Multer Storage Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const { firstName, lastName } = req.body;
    const fileExtension = path.extname(file.originalname);
    cb(null, `${firstName}${lastName}(ValidID)${fileExtension}`);
  }
});

const upload = multer({ storage });

// MSSQL Configuration
const sqlConfig = {
  user: 'sa',
  password: 'Eugene12042001',
  server: 'LAPTOP-NI-POGI',
  database: 'NEMPA',
  options: {
    instanceName: "SQLEXPRESS",
    encrypt: false,
    trustServerCertificate: true,
  },
  connectionTimeout: 15000,
  requestTimeout: 15000,
};

// Create a connection pool once
let pool;

async function connectToDatabase() {
  if (!pool) {
    try {
      pool = await mssql.connect(sqlConfig);
      console.log('Connected to the database successfully');
    } catch (err) {
      console.error('Database connection failed:', err);
      process.exit(1); // Exit if connection fails
    }
  }
  return pool;
}

// ðŸ“Œ Middleware to parse form-data and handle file upload
app.post('/submit', upload.single('validId'), async (req, res) => {
  const { lastName, firstName, middleName, birthday, contactNumber, address, dataRegistered } = req.body;
  const validIdFileName = req.file ? req.file.filename : 'No file uploaded';

  try {
    const pool = await connectToDatabase();
    const currentYear = new Date().getFullYear();

    // Check if the client already exists based on fname, mname, and lname
    const existingClient = await pool.request()
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('lastName', mssql.NVarChar, lastName)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE fname = @firstName AND mname = @middleName AND lname = @lastName
      `);

    if (existingClient.recordset.length > 0) {
      // Client already exists, generate JWT token with existing clientId
      const clientId = existingClient.recordset[0].client_id;
      const token = jwt.sign(
        { clientId, firstName, lastName },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
      );

      return res.status(200).json({ message: 'Client already exists', clientId, token });
    }

    // Get the highest client_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE client_id LIKE CONCAT(@currentYear, '%')
        ORDER BY client_id DESC
      `);

    let clientId = `${currentYear}01`;

    if (result.recordset.length > 0) {
      const lastClientId = result.recordset[0].client_id;
      const newIdNumber = parseInt(lastClientId.slice(-2), 10) + 1;
      clientId = `${currentYear}${String(newIdNumber).padStart(2, '0')}`;
    }

    // Insert new client data if client does not exist
    await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('lastName', mssql.NVarChar, lastName)
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('birthday', mssql.NVarChar, birthday)
      .input('contactNumber', mssql.NVarChar, contactNumber)
      .input('address', mssql.NVarChar, address)
      .input('validIdFileName', mssql.NVarChar, validIdFileName)
      .input('dataRegistered', mssql.NVarChar, dataRegistered)
      .query(`
        INSERT INTO client_info (client_id, lname, fname, mname, bday, cont_num, address, valid_id, reg_date)
        VALUES (@clientId, @lastName, @firstName, @middleName, @birthday, @contactNumber, @address, @validIdFileName, @dataRegistered)
      `);

    // Generate JWT Token for new client
    const token = jwt.sign(
      { clientId, firstName, lastName },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    res.status(200).json({ message: 'Data inserted successfully!', clientId, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Error inserting data into the database.' });
  }
});



// The route to handle loan submissions
app.post('/submit-loan', async (req, res) => {
  const { clientId, loanAmount, loanInterest, noOfMonths, loanDate, total, biWeeklyAmortization, OldloanId } = req.body;

  try {
    console.log('Request Body:', req.body);
    const pool = await mssql.connect(sqlConfig);
    const balanceResult = await pool.request()
      .query('SELECT TOP 1 remaining_Bal FROM coop_balance');
    const remainingBal = balanceResult.recordset[0] ? balanceResult.recordset[0].remaining_Bal : 0;

    // Check if loanAmount is greater than remaining_Bal
    if (loanAmount > remainingBal) {
      return res.status(400).json({ message: 'Insufficient remaining balance to process the loan.' });
    }
    // Generate loan reference number (loanRefNo) with the current year and incrementing number
    const currentYear = new Date().getFullYear();
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 LoanRefNo
        FROM Loans
        WHERE LoanRefNo LIKE '${currentYear}%'
        ORDER BY LoanRefNo DESC
      `);

    let loanRefNo = `${currentYear}0001`;  // Default to the first loan of the year

    if (result.recordset.length > 0) {
      const lastLoanRefNo = result.recordset[0].LoanRefNo; // Ensure correct column name (case-sensitive)
      
      if (lastLoanRefNo) {
        const newRefNo = parseInt(lastLoanRefNo.slice(-4)) + 1;
        loanRefNo = `${currentYear}${String(newRefNo).padStart(4, '0')}`;
      } else {
        console.error('No valid loanRefNo found');
        loanRefNo = `${currentYear}0001`; // Reset if the reference number is invalid
      }
    }

    // Get client_id from Loans table if clientId is null or empty
    let finalClientId = clientId;
    if (!clientId) {
      const clientIdResult = await pool.request()
        .input('OldloanId', mssql.NVarChar, OldloanId)
        .query(`
          SELECT client_id
          FROM Loans
          WHERE LoanRefNo = @OldloanId
        `);
      if (clientIdResult.recordset.length > 0) {
        finalClientId = clientIdResult.recordset[0].client_id;
        console.log('Retrieved client_id:', finalClientId);
      } else {
        throw new Error('Could not find client_id for the given OldloanId');
      }
    }

    const noOfTerms = noOfMonths * 2;  // Assuming bi-weekly payments
    const status = 'Waiting for Approval';
    const notReleased = 'No';
    const interest_Amount = total - loanAmount;
    // Insert the loan data into the loan table
    const resultInsert = await pool.request()
      .input('clientId', mssql.NVarChar, finalClientId)
      .input('loanRefNo', mssql.NVarChar, loanRefNo)
      .input('loanAmount', mssql.Float, loanAmount)
      .input('loanInterest', mssql.Int, loanInterest)
      .input('noOfMonths', mssql.Int, noOfMonths)
      .input('loanDate', mssql.Date, loanDate)  // Insert the loan date
      .input('total', mssql.Float, total)
      .input('biWeeklyAmortization', mssql.Float, biWeeklyAmortization)
      .input('noOfTerms', mssql.Int, noOfTerms)
      .input('onGoing', mssql.NVarChar, status)
      .input('notReleased', mssql.NVarChar, notReleased)
      .input('interest_Amount', mssql.Float, interest_Amount)
      .query(`
        INSERT INTO Loans (LoanRefNo, client_id, LoanAmount, interest, noOfMonths, LoanDate, TotalAmount, biWeeklyPay, running_balance, no_of_terms, status, isReleased,interest_Amount)
        VALUES (@loanRefNo, @clientId, @loanAmount, @loanInterest, @noOfMonths, @loanDate, @total, @biWeeklyAmortization, @total, @noOfTerms, @onGoing, @notReleased, @interest_Amount)
      `);

    // Return response with the loan reference number
    res.status(200).json({
      message: 'Loan data inserted successfully!',
      loanRefNo
    });
  } catch (err) {
    console.error('Error inserting loan data:', err);
    res.status(500).json({ message: 'Error inserting loan data.' });
  }
});




app.get('/loanData', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1]; // Assuming Bearer token format
  if (!token) {
    return res.status(400).send('Token missing');
  }

  const decodedToken = jwtDecode(token);
  const { loanRefNo, clientId } = decodedToken;
  const status = 'On Going';
  try {
    const pool = await mssql.connect(sqlConfig); // Ensure that sqlConfig is defined and correct
    const result = await pool.request() // Corrected query using pool.request()
      .input('loanRefNo', mssql.NVarChar, loanRefNo) // Use parameterized queries for security
      .input('clientId', mssql.NVarChar, clientId)
      .input('onGoing', mssql.NVarChar, status)
      .query(`
        SELECT LoanRefNo, client_id, LoanAmount, TotalAmount, noOfMonths, LoanDate, interest, biWeeklyPay,running_balance 
        FROM Loans 
        WHERE LoanRefNo = @loanRefNo AND client_id = @clientId AND status = @onGoing
      `);

    if (result.recordset.length > 0) {
      res.json(result.recordset[0]); // Send loan data back
    } else {
      res.status(404).send('Loan not found');
    }
  } catch (error) {
    console.error('Database query error', error);
    res.status(500).send('Internal server error');
  }
});


// âœ… Function to ensure the date is not on a weekend (only for NextPaymentDate)
function avoidWeekends(date) {
  const day = date.getDay(); // 0 is Sunday, 6 is Saturday
  if (day === 6) { // Saturday
    date.setDate(date.getDate() + 2); // Move to Monday
  } else if (day === 0) { // Sunday
    date.setDate(date.getDate() + 1); // Move to Monday
  }
  return date;
}

app.post("/make-payment", async (req, res) => {
  const { currentLoanId, paymentDate, payment } = req.body;
  // Update the remaining balance in coop_balance
  await pool.request()
  .input("paymentAmount", mssql.Float, payment)
  .query(`
    UPDATE coop_balance
    SET remaining_Bal = remaining_Bal + @paymentAmount
  `);
  await pool.request()
  .input("paymentAmount", mssql.Float, payment)
  .query(`
    UPDATE coop_balance 
    SET used_Bal = CASE
      WHEN used_Bal - @paymentAmount < 0 THEN 0
      ELSE used_Bal - @paymentAmount
    END
  `);
  
  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // âœ… Generate unique PaymentID
    const result = await pool.request()
      .input("currentYear", mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID FROM Payments 
        WHERE PaymentID LIKE '${currentYear}%' ORDER BY PaymentID DESC
      `);

    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastPaymentID = result.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }
    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, "0")}`;

    // âœ… Check if it's the first payment
    const lastPayment = await pool.request()
      .input("loanRefNo", mssql.NVarChar, currentLoanId)
      .query(`
        SELECT TOP 1 NextPaymentDate 
        FROM Payments 
        WHERE LoanRefNo = @loanRefNo 
        ORDER BY PaymentDateTo DESC
      `);

    let paymentDateFrom, paymentDateTo, nextPaymentDate;

    if (lastPayment.recordset.length === 0) {
      // ðŸ”¹ First-time payment: Use releasedWhen as PaymentDateFrom and PaymentStartAt as PaymentDateTo
      const firstPaymentDate = await pool.request()
        .input("loanRefNo", mssql.NVarChar, currentLoanId)
        .query(`SELECT releasedWhen, PaymentStartAt FROM Loans WHERE LoanRefNo = @loanRefNo`);
    
      if (firstPaymentDate.recordset.length > 0) {
        paymentDateFrom = new Date(firstPaymentDate.recordset[0].releasedWhen);  // releasedWhen as PaymentDateFrom
        paymentDateTo = new Date(firstPaymentDate.recordset[0].PaymentStartAt); // PaymentStartAt as PaymentDateTo
      } else {
        return res.status(400).json({ message: "LoanRefNo not found in Loans table." });
      }

      // âœ… Add 15 days to PaymentDateTo to get NextPaymentDate
      nextPaymentDate = new Date(paymentDateTo);
      nextPaymentDate.setDate(paymentDateTo.getDate() + 15);  // Add 15 days for the NextPaymentDate

      // âœ… Avoid weekends for NextPaymentDate only
      nextPaymentDate = avoidWeekends(nextPaymentDate);
    } else {
      // ðŸ”¹ Next payments: Use the NextPaymentDate of the previous payment
      nextPaymentDate = new Date(lastPayment.recordset[0].NextPaymentDate);
      paymentDateTo = new Date(nextPaymentDate);  // PaymentDateTo is the NextPaymentDate of the previous payment

      // Calculate PaymentDateFrom as 15 days before NextPaymentDate
      paymentDateFrom = new Date(nextPaymentDate);
      paymentDateFrom.setDate(paymentDateFrom.getDate() - 14);  // Ensure it's exactly 15 days earlier

      // **DO NOT avoid weekends on PaymentDateFrom or PaymentDateTo**. These should always be exactly 15 days apart.
    }

    // Convert dates to YYYY-MM-DD format
    const formattedPaymentDateFrom = paymentDateFrom.toISOString().split("T")[0];
    const formattedPaymentDateTo = paymentDateTo.toISOString().split("T")[0];
    const formattedNextPaymentDate = nextPaymentDate.toISOString().split("T")[0];

    // âœ… Insert payment into Payments table
    const insertedPayment = await pool.request()
      .input("PaymentID", mssql.NVarChar, nextPaymentID)
      .input("LoanRefNo", mssql.NVarChar, currentLoanId)
      .input("PaymentAmount", mssql.Decimal(18, 2), payment)
      .input("PaymentDateFrom", mssql.Date, formattedPaymentDateFrom)
      .input("PaymentDateTo", mssql.Date, formattedPaymentDateTo)
      .query(`
        INSERT INTO Payments (PaymentID, LoanRefNo, PaymentAmount, PaymentDateFrom, PaymentDateTo)
        OUTPUT INSERTED.PaymentID
        VALUES (@PaymentID, @LoanRefNo, @PaymentAmount, @PaymentDateFrom, @PaymentDateTo)
      `);

    const newPaymentID = insertedPayment.recordset[0].PaymentID;

    // âœ… Update running balance
    await pool.request()
      .input("LoanRefNo", mssql.NVarChar, currentLoanId)
      .input("PaymentAmount", mssql.Decimal(18, 2), payment)
      .query(`
        UPDATE Loans
        SET running_balance = running_balance - @PaymentAmount
        WHERE LoanRefNo = @LoanRefNo
      `);

    // âœ… Get updated loan details
    const updatedLoan = await pool.request()
      .input("LoanRefNo", mssql.NVarChar, currentLoanId)
      .query(`
        SELECT running_balance, TotalAmount, biWeeklyPay 
        FROM Loans WHERE LoanRefNo = @LoanRefNo
      `);

    const updatedData = updatedLoan.recordset[0];

    // âœ… If fully paid, update loan status
    const fullyPaidDate = new Date(); // Get the current date as a Date object
    const dateAsString = fullyPaidDate.toISOString().split("T")[0];
    if (updatedData.running_balance <= 0) {
      // Update loan status to "Fully Paid"
      await pool.request()
        .input("fullyPaid", mssql.NVarChar, "Fully Paid")
        .input("fullyPaidDate", mssql.NVarChar, dateAsString) // Pass the Date object directly
        .input("LoanRefNo", mssql.NVarChar, currentLoanId)
        .query(`
          UPDATE Loans 
          SET status = @fullyPaid, fullyPaidAt = @fullyPaidDate 
          WHERE LoanRefNo = @LoanRefNo
        `);
    
      // Update PaymentDateFrom, PaymentDateTo, and NextPaymentDate to 'Paid'
      await pool.request()
        .input("LoanRefNo", mssql.NVarChar, currentLoanId)
        .input("PaymentID", mssql.NVarChar, newPaymentID)
        .query(`
          UPDATE Payments 
          SET NextPaymentDate = 'Paid' 
          WHERE LoanRefNo = @LoanRefNo AND PaymentID = @PaymentID
        `);
    
      // Calculate the total sum of all payment amounts
      const totalPayments = await pool.request()
        .input("LoanRefNo", mssql.NVarChar, currentLoanId)
        .query(`
          SELECT SUM(PaymentAmount) AS TotalPayments 
          FROM Payments 
          WHERE LoanRefNo = @LoanRefNo
        `);
    
      const totalPaidAmount = totalPayments.recordset[0].TotalPayments;
      // Update TotalAmountPaid in the Loans table
      await pool.request()
        .input("LoanRefNo", mssql.NVarChar, currentLoanId)
        .input("totalPaidAmount", mssql.Decimal(18, 2), totalPaidAmount)
        .query(`
          UPDATE Loans
          SET TotalAmountPaid = @totalPaidAmount
          WHERE LoanRefNo = @LoanRefNo
        `);
      // Respond back with a success message
      return res.status(200).json({
        message: "Loan fully paid and updated successfully!",
      });
    }
    // âœ… Ensure `@PaymentID` exists in UPDATE query for NextPaymentDate
    const NextDueDate = new Date(paymentDateTo);
    NextDueDate.setDate(paymentDateTo.getDate() + 15);
    const formattedNextDueDate = avoidWeekends(NextDueDate).toISOString().split("T")[0];

    await pool.request()
      .input("LoanRefNo", mssql.NVarChar, currentLoanId)
      .input("PaymentID", mssql.NVarChar, newPaymentID)
      .input("NextPaymentDate", mssql.Date, formattedNextDueDate)
      .query(`
        UPDATE Payments SET NextPaymentDate = @NextPaymentDate 
        WHERE LoanRefNo = @LoanRefNo AND PaymentID = @PaymentID
      `);
    res.status(200).json({
      updatedLoanAmount: updatedData.running_balance,
      updatedTotalAmount: updatedData.TotalAmount,
      updatedbiWeeklyAmount: updatedData.biWeeklyPay,
      nextPaymentDate: formattedNextDueDate,
      message: "Payment recorded successfully!",
    });

  } catch (error) {
    console.error("Error processing payment:", error);
    res.status(500).json({ message: "Error processing payment.", error: error.message });
  }
});



app.get('/PendingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.LoanDate, l.LoanAmount, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status IN ('Waiting for Approval', 'Approved')
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      date: row.LoanDate,
      status: row.status,
      amount: row.LoanAmount,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.post('/submitLoanApprovals', async (req, res) => {
  const { loanId, approvedDate, approvers } = req.body; // approvers is an array

  if (!Array.isArray(approvers) || approvers.length === 0) {
    return res.status(400).json({ success: false, message: "Approvers list is empty or invalid." });
  }

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // Query the latest approved_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 approved_id
        FROM approvers
        WHERE approved_id LIKE '${currentYear}%'
        ORDER BY approved_id DESC
      `);

    // Determine the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastApprovedID = result.recordset[0].approved_id; // Correct column reference
      nextSeries = parseInt(lastApprovedID.slice(-6)) + 1;
    }

    // Insert each approver as a new row
    for (let i = 0; i < approvers.length; i++) {
      const nextApproverID = `${currentYear}${String(nextSeries + i).padStart(6, '0')}`;

      await pool.request()
        .input('ApprovedId', mssql.NVarChar, nextApproverID)
        .input('LoanRefNo', mssql.Int, loanId)
        .input('Date', mssql.Date, approvedDate)
        .input('Approver', mssql.NVarChar, approvers[i]) // Insert individual approver
        .query(`
          INSERT INTO approvers (approved_id, LoanRefNo, approvedDate, approver_name)
          VALUES (@ApprovedId, @LoanRefNo, @Date, @Approver)
        `);
    }

    // Update the status of the loan to "Approved"
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanId)
      .query(`
        UPDATE Loans
        SET status = 'Approved'
        WHERE LoanRefNo = @LoanRefNo
      `);

    res.status(200).json({ success: true, message: 'Loan approval submitted successfully.' });

  } catch (error) {
    console.error('Error processing loan approval:', error);
    return res.status(500).json({ success: false, message: 'Internal server error.' });
  }
});

app.get('/fetchApprovers/:loanId', async (req, res) => {
  const loanId = req.params.loanId;  // Get loanId from URL params

  try {
    // Query the database for approvers related to the loanId
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId) // Assuming loanId is an integer
      .query('SELECT approver_name FROM approvers WHERE LoanRefNo = @loanId');  // Your query to fetch approvers

    if (result.recordset.length > 0) {
      // If approvers are found, send them as the response
      res.json({
        success: true,
        approvers: result.recordset.map(row => ({
          name: row.approver_name,  // Assuming the column in the database is `approver_name`
        })),
      });
    }
  } catch (err) {
    console.error('Error fetching approvers:', err);
    res.status(500).json({ success: false, message: 'Error fetching approvers' });
  }
});

wss.on("connection", (ws) => {
  console.log("New client connected");

  // Check if the client is already in the set (avoid duplicates)
  if (!clients.has(ws)) {
    clients.add(ws);
  }

  // Function to fetch loan counts
  const sendLoanCounts = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query(`
        SELECT 
          (SELECT COUNT(*) 
           FROM Loans 
           WHERE status = 'Waiting for Approval') AS pendingCount,
  
          -- Count the number of released loans where PaymentDateTo or PaymentStartAt is today
          (SELECT COUNT(*) 
           FROM Loans l
           LEFT JOIN Payments p ON l.LoanRefNo = p.LoanRefNo
           WHERE l.status = 'Released' 
           AND (
             CONVERT(DATE, ISNULL(p.PaymentDateTo, l.PaymentStartAt)) = CONVERT(DATE, GETDATE())
           )
          ) AS releasedCount
      `);
  
      const counts = {
        type: "loanCounts",
        pendingCount: result.recordset[0].pendingCount,
        releasedCount: result.recordset[0].releasedCount,
      };
  
      // Send updates to all connected clients
      clients.forEach((client) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(counts));
        }
      });
  
    } catch (error) {
      console.error("Error fetching loan counts:", error);
    }
  };
  
  // Send initial data when a client connects
  sendLoanCounts();

  // Start interval only once for the first client
  if (clients.size === 1) {
    console.log("Starting loan update interval...");
    global.loanUpdateInterval = setInterval(sendLoanCounts, 10000);
  }

  // Cleanup when client disconnects
  ws.on("close", () => {
    console.log("Client disconnected");
    clients.delete(ws);

    // Stop the interval if no clients are connected
    if (clients.size === 0) {
      console.log("No clients connected, stopping interval...");
      clearInterval(global.loanUpdateInterval);
      delete global.loanUpdateInterval;
    }
  });
});

app.post('/releaseLoan', async (req, res) => {
  const { loanId, releasedBy, releasedDate, PaymentStartAt } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);
    
    const loanResult = await pool.request()
      .input('loanId', mssql.Int, loanId) // Ensure proper input type (assuming loanId is an integer)
      .query(`
        SELECT LoanAmount FROM Loans WHERE LoanRefNo = @loanId
      `);
      // If no loan found
    if (loanResult.recordset.length === 0) {
      return res.status(404).json({ error: 'Loan not found' });
    }
    const loanAmount = loanResult.recordset[0].LoanAmount;
      // Fetch the current remaining_Bal from coop_balance
    const balanceResult = await pool.request()
    .query('SELECT remaining_Bal FROM coop_balance');

    if (balanceResult.recordset.length === 0) {
    return res.status(404).json({ error: 'No balance found' });
    }

    const remainingBalance = balanceResult.recordset[0].remaining_Bal;

    // Subtract LoanAmount from remaining_Bal
    const newRemainingBalance = remainingBalance - loanAmount;

    // Update coop_balance with new remaining_Bal and used_Bal
    await pool.request()
    .query(`
      UPDATE coop_balance
      SET remaining_Bal = ${newRemainingBalance}, used_Bal = ${loanAmount}
    `);
    console.log('releasedBy:', releasedBy);
    // Update the loan status to Released and set other fields
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('releasedBy', mssql.NVarChar, releasedBy) 
      .input('releasedDate', mssql.Date, releasedDate)
      .input('PaymentStartAt', mssql.Date, PaymentStartAt)
      .query(`
        UPDATE Loans
        SET isReleased = 'Yes', status = 'Released', releasedBy = @releasedBy, releasedWhen = @releasedDate, PaymentStartAt = @PaymentStartAt
        WHERE LoanRefNo = @loanId
      `);

    res.status(200).json({ message: 'Loan Released successfully!' });

  } catch (err) {
    console.error('Error releasing loan:', err);
    res.status(500).json({ message: 'Error releasing loan.' });
  }
});

app.get('/OnGoingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);

    // Fetch all ongoing loans (status = 'Released')
    const result = await pool.request().query(`
      SELECT 
          l.LoanRefNo, 
          l.biWeeklyPay, 
          l.running_balance, 
          l.PaymentStartAt, 
          l.status, 
          c.fname, 
          c.lname,
          -- Get the latest NextPaymentDate only for the newest inserted row
          COALESCE(
              (SELECT TOP 1 NextPaymentDate 
              FROM Payments p
              WHERE p.LoanRefNo = l.LoanRefNo 
              ORDER BY p.PaymentDateTo DESC, p.PaymentID DESC), -- âœ… Ensures newest record
              l.PaymentStartAt
          ) AS DueDate
      FROM Loans l
      JOIN client_info c ON l.client_id = c.client_id
      WHERE l.status = 'Released';
    `);
    

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      dueDate: row.DueDate, // âœ… Ensuring newest NextPaymentDate is used
      biWeeklyPay: row.biWeeklyPay,
      amount: row.running_balance,
      status: row.status,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));
    console.log(loans.loanAmount);
    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.get('/PaidLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);

    // Fetch all fully paid loans (status = 'Fully Paid')
    const result = await pool.request().query(`
      SELECT 
          l.LoanRefNo,
          l.LoanAmount,
          l.Interest,
          l.fullyPaidAt, 
          l.TotalAmountPaid,
          l.status, 
          c.fname, 
          c.lname
      FROM Loans l
      JOIN client_info c ON l.client_id = c.client_id
      WHERE l.status = 'Fully Paid';
    `);
    
    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      clientId: row.client_id,
      fullyPaidAt: row.fullyPaidAt, // âœ… Ensuring newest NextPaymentDate is used
      loanAmount: row.LoanAmount,
      totalAmountPaid: row.TotalAmountPaid,
      interest: row.Interest,
      status: row.status,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));
    console.log(loans.loanAmount);
    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});


app.post('/fetchLoanDetails', async (req, res) => {
  const { loanId } = req.body;
  try {
    const pool = await mssql.connect(sqlConfig);
    
    // Get loan details and total payments in a single query
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(`
        SELECT 
          l.*,
          ISNULL((
            SELECT SUM(PaymentAmount) 
            FROM Payments 
            WHERE LoanRefNo = @loanId
          ), 0) as TotalPayments
        FROM Loans l
        WHERE l.LoanRefNo = @loanId
      `);

    if (result.recordset.length > 0) {
      const loanDetails = result.recordset[0];
      res.json(loanDetails);
    } else {
      res.status(404).json({ message: 'Loan not found.' });
    }

  } catch (err) {
    console.error('Error fetching loan details:', err);
    res.status(500).json({ message: 'Error fetching loan details.' });
  }
});

// Backend Route for Balance Data and Monthly Income Combined
wss.on('connection', (ws) => {
  console.log('New WebSocket client connected');

  // Fetch data for coop_balance (total balance)
  const fetchCoopBalanceAndSend = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);

      // Query to get the balance data from coop_balance
      const result = await pool.request()
        .query(`
          SELECT 
            remaining_Bal AS totalBalance, 
            used_Bal AS usedBalance,
            beginning_Bal AS beginningBalance
          FROM coop_balance
        `);

      if (!result.recordset || result.recordset.length === 0) {
        console.log("No data returned from the coop_balance table.");
        ws.send(JSON.stringify({ error: 'No data returned from the coop_balance table.' }));
        return;
      }

      const data = {
        type: 'balance_data',
        totalBalance: result.recordset[0].totalBalance || 0,
        usedBalance: result.recordset[0].usedBalance || 0,
        beginningBalance: result.recordset[0].beginningBalance || 0
      };

      // Send the coop_balance data to the client
      ws.send(JSON.stringify(data));
    } catch (err) {
      console.error('Error fetching coop_balance data:', err);
      ws.send(JSON.stringify({ error: 'Failed to fetch coop_balance data' }));
    }
  };

  // Fetch data for monthly income
  const fetchMonthlyIncomeAndSend = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);

      // Query to get the monthly income data from Loans table
      const result = await pool.request()
        .query(`
          SELECT 
            FORMAT(CAST(fullyPaidAt AS DATETIME), 'yyyy-MM') AS paymentMonth,
            SUM(interest_Amount) AS monthlyIncome
          FROM Loans
          WHERE status IN ('Fully Paid', 'Recomputed') 
            AND fullyPaidAt IS NOT NULL
          GROUP BY FORMAT(CAST(fullyPaidAt AS DATETIME), 'yyyy-MM')
        `);

      if (!result.recordset || result.recordset.length === 0) {
        console.log("No data returned from the Loans table.");
        ws.send(JSON.stringify({ error: 'No data returned from the Loans table.' }));
        return;
      }

      const data = {
        type: 'monthly_income_data',
        monthlyIncome: {}  // To store monthly income by month key (yyyy-MM)
      };

      // Organize the data by month
      result.recordset.forEach(row => {
        const month = row.paymentMonth;
        data.monthlyIncome[month] = row.monthlyIncome;
      });

      // Ensure all months are accounted for (filling missing months with 0)
      const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
      const monthlyIncomeData = months.map(month => {
        const monthKey = `2025-${month}`;
        return data.monthlyIncome[monthKey] || 0; // Default to 0 if no income for the month
      });

      // Send the monthly income data to the client
      ws.send(JSON.stringify({
        type: 'monthly_income_data',
        monthlyIncome: monthlyIncomeData
      }));
    } catch (err) {
      console.error('Error fetching monthly income data:', err);
      ws.send(JSON.stringify({ error: 'Failed to fetch monthly income data' }));
    }
  };

  // Fetch data for loan requests per month (LoanDate)
  const fetchLoanRequestsPerMonthAndSend = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);

      // Query to get the loan requests per month (LoanDate column)
      const result = await pool.request()
        .query(`
          SELECT 
            FORMAT(CAST(LoanDate AS DATETIME), 'yyyy-MM') AS requestMonth, 
            COUNT(*) AS loanRequests
          FROM Loans
          WHERE LoanDate IS NOT NULL
          GROUP BY FORMAT(CAST(LoanDate AS DATETIME), 'yyyy-MM')
        `);

      if (!result.recordset || result.recordset.length === 0) {
        console.log("No data returned from the Loans table for loan requests.");
        ws.send(JSON.stringify({ error: 'No data returned from the Loans table for loan requests.' }));
        return;
      }

      const data = {
        type: 'loan_requests_data',
        loanRequestsPerMonth: {}  // To store loan requests by month key (yyyy-MM)
      };

      // Organize the data by month
      result.recordset.forEach(row => {
        const month = row.requestMonth;
        data.loanRequestsPerMonth[month] = row.loanRequests;
      });

      // Ensure all months are accounted for (filling missing months with 0)
      const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
      const loanRequestsData = months.map(month => {
        const monthKey = `2025-${month}`;
        return data.loanRequestsPerMonth[monthKey] || 0; // Default to 0 if no requests for the month
      });

      // Send the loan requests per month data to the client
      ws.send(JSON.stringify({
        type: 'loan_requests_data',
        loanRequestsPerMonth: loanRequestsData
      }));
    } catch (err) {
      console.error('Error fetching loan requests per month data:', err);
      ws.send(JSON.stringify({ error: 'Failed to fetch loan requests per month data' }));
    }
  };

  // Fetch data for released loans per month (releasedWhen)
  const fetchReleasedLoansPerMonthAndSend = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);

      // Query to get the released loans per month (releasedWhen column)
      const result = await pool.request()
        .query(`
          SELECT 
            FORMAT(CAST(releasedWhen AS DATETIME), 'yyyy-MM') AS releaseMonth, 
            COUNT(*) AS releasedLoans
          FROM Loans
          WHERE releasedWhen IS NOT NULL
          GROUP BY FORMAT(CAST(releasedWhen AS DATETIME), 'yyyy-MM')
        `);

      if (!result.recordset || result.recordset.length === 0) {
        console.log("No data returned from the Loans table for released loans.");
        ws.send(JSON.stringify({ error: 'No data returned from the Loans table for released loans.' }));
        return;
      }

      const data = {
        type: 'released_loans_data',
        releasedLoansPerMonth: {}  // To store released loans by month key (yyyy-MM)
      };

      // Organize the data by month
      result.recordset.forEach(row => {
        const month = row.releaseMonth;
        data.releasedLoansPerMonth[month] = row.releasedLoans;
      });

      // Ensure all months are accounted for (filling missing months with 0)
      const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
      const releasedLoansData = months.map(month => {
        const monthKey = `2025-${month}`;
        return data.releasedLoansPerMonth[monthKey] || 0; // Default to 0 if no releases for the month
      });

      // Send the released loans per month data to the client
      ws.send(JSON.stringify({
        type: 'released_loans_data',
        releasedLoansPerMonth: releasedLoansData
      }));
    } catch (err) {
      console.error('Error fetching released loans per month data:', err);
      ws.send(JSON.stringify({ error: 'Failed to fetch released loans per month data' }));
    }
  };

  // Send initial data when the client connects
  fetchCoopBalanceAndSend();
  fetchMonthlyIncomeAndSend();
  fetchLoanRequestsPerMonthAndSend();
  fetchReleasedLoansPerMonthAndSend();

  // Send periodic updates every 10 seconds
  const intervalId = setInterval(() => {
    fetchCoopBalanceAndSend();
    fetchMonthlyIncomeAndSend();
    fetchLoanRequestsPerMonthAndSend();
    fetchReleasedLoansPerMonthAndSend();
  }, 10000);

  // Listen for messages from the client
  ws.on('message', (message) => {
    console.log('Received message:', message);
  });

  // Cleanup when the connection is closed
  ws.on('close', () => {
    console.log('WebSocket client disconnected');
    clearInterval(intervalId); // Clear the interval when the client disconnects
  });
});

app.get('/FetchLoanDetails/:loanId', async (req, res) => {
  const { loanId } = req.params;
  console.log(loanId);
  try {
    const pool = await mssql.connect(sqlConfig);
    
    // Query to get loan payments for a given loanId
    const paymentsQuery = `
      SELECT PaymentDateFrom, PaymentDateTo, PaymentAmount
      FROM Payments
      WHERE LoanRefNo = @loanId
    `;
    
    // Query to get loan approvers for the given loanId
    const approversQuery = `
      SELECT approver_name
      FROM approvers
      WHERE LoanRefNo = @loanId
    `;
    const releasedByQuery = `
      SELECT releasedBy
      FROM Loans
      WHERE LoanRefNo = @loanId
    `;
    const clientIdQuery = `
      SELECT client_id
      FROM Loans
      WHERE LoanRefNo = @loanId
    `;
    // Running both queries in parallel
    const paymentsResult = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(paymentsQuery);
    
    const approversResult = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(approversQuery);
    
      const releasedByResult = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(releasedByQuery);

    const clientIdResult = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(clientIdQuery);


    // Send the results as JSON
    res.json({
      loanPayments: paymentsResult.recordset,
      loanApprovers: approversResult.recordset,
      releasedByWho: releasedByResult.recordset,
      clientId: clientIdResult.recordset
    });
    console.log(paymentsResult.recordset);
    console.log(approversResult.recordset);
    console.log(releasedByResult.recordset);
    console.log(clientIdResult.recordset);
    console.log(clientIdResult.recordset);
    
  } catch (err) {
    console.error('Error fetching loan details:', err);
    res.status(500).json({ message: 'Error fetching loan details.' });
  }
});

/// Route to fetch all loan details
app.get('/fetch-all-loan-details', async (req, res) => {
  try {
    // Query to fetch loan details including client_id
    const loanQuery = `
      SELECT l.LoanRefNo, l.fullyPaidAt, l.totalAmountPaid, l.status, l.releasedBy, l.client_id,
             c.fname, c.lname
      FROM Loans l
      LEFT JOIN client_info c ON l.client_id = c.client_id
      WHERE l.status IN ('Released', 'Fully Paid', 'Recomputed');
    `;

    const result = await pool.request().query(loanQuery);
    const loanRows = result.recordset;

    if (!Array.isArray(loanRows)) {
      return res.status(500).json({ error: 'Unexpected response structure from the database' });
    }

    if (loanRows.length === 0) {
      return res.status(200).json({ message: 'No loans found' });
    }

    const loanRefNos = loanRows.map(row => row.LoanRefNo);

    // Query to fetch payments
    const paymentsQuery = `
      SELECT LoanRefNo, PaymentAmount, PaymentDateTo 
      FROM Payments 
      WHERE LoanRefNo IN (${loanRefNos.map(refNo => `'${refNo}'`).join(', ')});
    `;

    const paymentResult = await pool.request().query(paymentsQuery);
    const paymentRows = paymentResult.recordset;

    // Combine the data into result
    const combinedResult = loanRefNos.map(refNo => {
      const loan = loanRows.find(loan => loan.LoanRefNo === refNo);
      const payments = paymentRows.filter(payment => payment.LoanRefNo === refNo);

      const latestPayment = payments.reduce((latest, current) => {
        if (!latest || new Date(current.PaymentDateTo) > new Date(latest.PaymentDateTo)) {
          return current;
        }
        return latest;
      }, null);

      let paymentDate = '';
      let displayAmount = 0;

      if (loan.status === 'Fully Paid' || loan.status === 'Fully Paid(Recomputed)') {
        paymentDate = latestPayment?.PaymentDateTo || '';
        displayAmount = loan.totalAmountPaid;
      } else if (loan.status === 'Released') {
        paymentDate = latestPayment?.PaymentDateTo || '';
        displayAmount = payments.reduce((total, payment) => total + payment.PaymentAmount, 0);
      }

      return {
        LoanRefNo: loan.LoanRefNo,
        Status: loan.status,
        TotalAmountPaid: loan.totalAmountPaid,
        ReleasedBy: loan.releasedBy,
        ClientId: loan.client_id,
        ClientName: `${loan.fname} ${loan.lname}`,
        Payments: payments.map(payment => ({
          PaymentAmount: loan.status === 'Fully Paid' || loan.status === 'Fully Paid(Recomputed)' ? loan.totalAmountPaid : payment.PaymentAmount,
          PaymentDate: payment.PaymentDateTo,
        })),
        DisplayAmount: displayAmount
      };
    });

    res.status(200).json(combinedResult);

  } catch (err) {
    console.error('Error fetching loan details:', err);
    res.status(500).json({ error: 'Failed to fetch loan details' });
  }
});

app.post('/PayRecomputedLoan', async (req, res) => {
  const { loanId, recomputedAmount, recomputeInterestValue, daterecomputed, dateNow, status, balance, startOfPayment } = req.body;
  
  try {
    const pool = await mssql.connect(sqlConfig);

    // Get next payment ID
    const currentYear = new Date().getFullYear();
    const paymentIdResult = await pool.request()
      .input("currentYear", mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID FROM Payments 
        WHERE PaymentID LIKE '${currentYear}%' ORDER BY PaymentID DESC
      `);

    let nextSeries = 1;
    if (paymentIdResult.recordset.length > 0) {
      const lastPaymentID = paymentIdResult.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }
    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, "0")}`;

    // Insert into Payments table
    await pool.request()
      .input('PaymentID', mssql.NVarChar, nextPaymentID)
      .input('loanId', mssql.NVarChar, loanId)
      .input('recomputedAmount', mssql.Float, recomputedAmount)
      .input('startOfPayment', mssql.Date, startOfPayment)
      .input('dateNow', mssql.Date, dateNow)
      .query(`
        INSERT INTO Payments (
          PaymentID,
          LoanRefNo,
          PaymentAmount,
          PaymentDateFrom,
          PaymentDateTo,
          NextPaymentDate
        )
        VALUES (
          @PaymentID,
          @loanId,
          @recomputedAmount,
          @startOfPayment,
          @dateNow,
          'Paid'
        )
      `);

    // Get payment count
    const countResult = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .query(`
        SELECT COUNT(*) as PaymentCount
        FROM Payments 
        WHERE LoanRefNo = @loanId
      `);

    const paymentCount = countResult.recordset[0].PaymentCount;
    // Update Loans table
    await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('recomputedAmount', mssql.Float, recomputedAmount)
      .input('recomputeInterestValue', mssql.Float, recomputeInterestValue)
      .input('daterecomputed', mssql.Date, daterecomputed)
      .input('dateNow', mssql.Date, dateNow)
      .input('status', mssql.VarChar, status)
      .input('balance', mssql.Float, balance)
      .input('paymentCount', mssql.Int, paymentCount)
      .input('no_of_months', mssql.Int, daterecomputed)
      .query(`
        UPDATE Loans
        SET status = @status, 
            running_balance = @balance, 
            fullyPaidAt = @dateNow, 
            totalAmountPaid = @recomputedAmount, 
            interest_Amount = @recomputeInterestValue,
            no_of_terms = @paymentCount,
            NoOfMonths = @no_of_months
        WHERE LoanRefNo = @loanId
      `);
      await pool.request()
      .input("paymentAmount", mssql.Float, recomputedAmount)
      .query(`
        UPDATE coop_balance
        SET remaining_Bal = remaining_Bal + @paymentAmount
      `);
      await pool.request()
      .input("paymentAmount", mssql.Float, recomputedAmount)
      .query(`
        UPDATE coop_balance 
        SET used_Bal = CASE
          WHEN used_Bal - @paymentAmount < 0 THEN 0
          ELSE used_Bal - @paymentAmount
        END
      `);

    res.status(200).json({ message: 'Loan recomputed successfully', paymentCount });

  } catch(error) {
    console.error("Error recomputing:", error);
    res.status(500).json({ message: 'Error recomputing.' });
  }
});

app.get('/getBalance', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request().query('SELECT remaining_Bal, used_Bal FROM coop_balance');

    if (result.recordset.length === 0) {
      return res.status(404).json({ message: 'No balance data found' });
    }
    // Return only the required columns
    const balanceData = result.recordset[0];
    res.status(200).json({
      remaining_Bal: balanceData.remaining_Bal,
      used_Bal: balanceData.used_Bal,
    });
  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ message: 'Error retrieving balance data' });
  }
});

app.post('/updateBalance', async (req, res) => {
  const { availableBalance, usedBalance, password } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);
    
    // Query to fetch the hashed password from the 'coop_password' table
    const result = await pool.request().query('SELECT password FROM coop_password');  // Assuming you have only one password entry or use the appropriate ID

    if (result.recordset.length === 0) {
      return res.status(404).json({ message: 'Password not found in database' });
    }

    const hashedPassword = result.recordset[0].password;

    // Compare the entered password with the stored hashed password using bcrypt
    const isMatch = await bcrypt.compare(password, hashedPassword);

    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid password' });
    }

    // Proceed to update the balance if password is correct
    await pool.request()
      .input('availableBalance', mssql.Float, availableBalance)
      .input('usedBalance', mssql.Float, usedBalance)
      .query(
        `UPDATE coop_balance 
        SET remaining_Bal = @availableBalance, 
        used_Bal = @usedBalance`
      );

    res.status(200).json({ message: 'Balance updated successfully' });

  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ message: 'Error updating balance' });
  }
});

app.post('/create-coop-account', async (req, res) => {
  const { name, lastName, email, password, regDate } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();
    const paymentIdResult = await pool.request()
      .input("currentYear", mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 admin_Id FROM nempa_Admin 
        WHERE admin_Id LIKE '${currentYear}%' ORDER BY admin_Id DESC
      `);

    let nextSeries = 1;
    if (paymentIdResult.recordset.length > 0) {
      const lastPaymentID = paymentIdResult.recordset[0].admin_Id;
      nextSeries = parseInt(lastPaymentID.slice(-4)) + 1;
    }
    const admin_Id = `${currentYear}${String(nextSeries).padStart(4, "0")}`;
    await pool.request()
      .input('admin_Id', mssql.VarChar, admin_Id)
      .input('name', mssql.VarChar, name)
      .input('lastName', mssql.VarChar, lastName)
      .input('email', mssql.VarChar, email)
      .input('password', mssql.VarChar, password)
      .input('regDate', mssql.Date, regDate)
      .query(`
        INSERT INTO nempa_Admin (admin_Id, fname, lname, email, password, registration_Date)
        VALUES (@admin_Id, @name, @lastName, @email, @password, @regDate)
      `);

    res.status(200).json({ message: 'Coop account created successfully' });
  } catch (error) {
    console.error("Database error:", error);
    res.status(500).json({ message: 'Error creating coop account' });
  }
});


app.post('/SignIn', async (req, res) => {
  const { email, password } = req.body;

  // Validate input
  if (!email || !password) {
    return res.status(400).json({ message: 'Email and password are required' });
  }

  try {
    // Connect to the database
    const pool = await mssql.connect(sqlConfig);

    // Query to fetch the hashed password for the provided email
    const result = await pool.request()
      .input('email', mssql.NVarChar, email)  // Using parameterized queries to avoid SQL injection
      .query('SELECT password, fname, lname FROM nempa_Admin WHERE email = @email');

    // Check if the email exists in the database
    if (result.recordset.length === 0) {
      return res.status(404).json({ message: 'Email not found in database' });
    }

    const hashedPassword = result.recordset[0].password;  // Retrieve hashed password

    // Compare the provided password with the hashed password
    const isMatch = await bcrypt.compare(password, hashedPassword);

    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid password' });
    }
    const adminName = result.recordset[0].fname + " " + result.recordset[0].lname;
    // Create a JWT token (you can add user info like ID or role here)
    const Admintoken = jwt.sign({ adminName },   process.env.JWT_SECRET, { expiresIn: '1h' });

    // Respond with success and the token
    res.status(200).json({ message: 'Login successful', Admintoken });
  } catch (error) {
    console.error("Error during sign-in:", error);
    res.status(500).json({ message: 'Error during login' });
  }
});



// Start the server
app.listen(port, async () => {
  await connectToDatabase(); // Ensure database is connected before accepting requests
  console.log(`Server running on port ${port}`);
});
