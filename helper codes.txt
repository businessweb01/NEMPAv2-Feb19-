// const Skeleton = styled('div')(({ theme, height }) => ({
//   backgroundColor: theme.palette.action.hover,
//   borderRadius: theme.shape.borderRadius,
//   height,
//   content: '" "',
// }))


import * as React from 'react';
import { ReactRouterAppProvider } from '@toolpad/core/react-router';
import { Outlet } from 'react-router';
import { AppProvider } from '@toolpad/core/AppProvider';
import { DashboardLayout } from '@toolpad/core/DashboardLayout';
import { PageContainer } from '@toolpad/core/PageContainer';
import { createTheme } from '@mui/material/styles';
import Stack from '@mui/material/Stack';
import Typography from '@mui/material/Typography';

// Pages
import ClientInfo from './pages/DE_client_info';
import Loan from './pages/DE_Loan';
import Payment from './pages/DE_of_payment';

// MUI Icons
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b', // Teal green
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
});

const NAVIGATION = [
  {
    segment: 'dashboard',
    title: 'Dashboard',
    icon: <DashboardIcon />,
  },
  {
    segment: 'loans',
    title: 'Loans',
    icon: <AccountBalanceIcon />,
    children: [
      {
        segment: 'Pending',
        title: 'Pending Loans',
        icon: <PendingActionsIcon />,
      },
      {
        segment: 'OnGoing',
        title: 'On Going Loans',
        icon: <AssuredWorkloadIcon />,
      },
      {
        segment: 'Paid',
        title: 'Paid Loans',
        icon: <CreditScoreIcon />,
      },
    ],
  },
  {
    segment: 'integrations',
    title: 'Transaction History',
    icon: <ReceiptLongIcon />,
  },
];

function CustomAppTitle() {
  return (
    <Stack direction="row" alignItems="center" spacing={2}>
      <Typography variant="h6">Loan Application</Typography>
    </Stack>
  );
}

export default function DashboardLayoutBasic(props) {
  return (
    <ReactRouterAppProvider navigation={NAVIGATION} theme={theme}>
      <DashboardLayout
        slots={{
          appTitle: CustomAppTitle,
        }}
      >
        <Outlet />
      </DashboardLayout>
    </ReactRouterAppProvider>
  );
}
|

  {
    segment: 'dashboard',
    title: 'Dashboard',
    icon: <DashboardIcon />,
  },
  {
    segment: 'orders',
    title: 'Loans',
    icon: <AccountBalanceIcon />,
    children: [
      {
        segment: 'Pending',
        title: 'Pending Loans',
        icon: <PendingActionsIcon />,
        action: (
          <Chip
            label={5}
            color="warning"
            style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
          />
        ),
        route: '/orders/Pending', // Correct route for Pending Loans
        component: <ClientInfo />, // Rendering ClientInfo for Pending Loans
      },
      {
        segment: 'OnGoing',
        title: 'On Going Loans',
        icon: <AssuredWorkloadIcon />,
        action: (
          <Chip
            label={5}
            color="warning"
            style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
          />
        ),
        route: '/orders/OnGoing', // Correct route for On Going Loans
        component: <Loan />, // Rendering Loan component for On Going Loans
      },
      {
        segment: 'Paid',
        title: 'Paid Loans',
        icon: <CreditScoreIcon />,
        route: '/orders/Paid', // Correct route for Paid Loans
        component: <Payment />, // Rendering Payment component for Paid Loans
      },
    ],
  },
  {
    segment: 'integrations',
    title: 'Transaction History',
    icon: <ReceiptLongIcon />,
    route: '/integrations',
    component: <Payment />, // Placeholder for Transaction History page
  },

    toast.custom((t) => (
            <div
              className={`${
                t.visible ? 'animate-enter' : 'animate-leave'
              } max-w-md w-full bg-white shadow-xl rounded-lg pointer-events-auto flex flex-col p-4`}
            >
              {/* First Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Amount:
                </div>
                <div className="text-sm text-gray-600">{loanAmount}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Interest Per Month:
                </div>
                <div className="text-sm text-gray-600">{(loanAmount * (loanInterest / 100)).toFixed(2)}</div>
              </div>
          
              {/* Second Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  No. of Months:
                </div>
                <div className="text-sm text-gray-600">{noOfMonths}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Total Loan:
                </div>
                <div className="text-sm text-gray-600">{total}</div>
              </div>
          
              {/* Third Layer */}
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Date:
                </div>
                <div className="text-sm text-gray-600">{new Date(loanDate).toLocaleDateString()}</div>
              </div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium text-gray-900 whitespace-nowrap">
                  Loan Ref No.:
                </div>
                <div className="text-sm text-gray-600">{loanRefNo}</div>
              </div>
          
              {/* Close Button */}
              <div className="mt-4 flex justify-center">
                <button
                  onClick={() => toast.dismiss(t.id)}
                  className="px-4 py-2 text-sm font-medium text-indigo-600 bg-indigo-100 rounded-md hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  Close
                </button>
              </div>
            </div>
          ));

            React.useEffect(() => {
    if (activeStep === 2) {
      // Automatically reset after 3 seconds
      setTimeout(() => {
        handleReset();
      }, 1500);
    }
  }, [activeStep]);

  const express = require('express');
const multer = require('multer');
const mssql = require('mssql');
const WebSocket = require('ws');
const path = require('path');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: '../.env.development' }); // Load .env file
const jwtDecode = require('jwt-decode');
// Set up express app
const app = express();
const port = 5000;
const wss = new WebSocket.Server({ port: 8080 });
// Enable CORS
app.use(cors()); // Allow all origins
app.use(express.json());
// Multer Storage Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const { firstName, lastName } = req.body;
    const fileExtension = path.extname(file.originalname);
    cb(null, `${firstName}${lastName}(ValidID)${fileExtension}`);
  }
});

const upload = multer({ storage });

// MSSQL Configuration
const sqlConfig = {
  user: 'sa',
  password: 'Eugene12042001',
  server: 'LAPTOP-NI-POGI',
  database: 'NEMPA',
  options: {
    instanceName: "SQLEXPRESS",
    encrypt: false,
    trustServerCertificate: true,
  },
  connectionTimeout: 15000,
  requestTimeout: 15000,
};

// Create a connection pool once
let pool;

async function connectToDatabase() {
  if (!pool) {
    try {
      pool = await mssql.connect(sqlConfig);
      console.log('Connected to the database successfully');
    } catch (err) {
      console.error('Database connection failed:', err);
      process.exit(1); // Exit if connection fails
    }
  }
  return pool;
}

// ðŸ“Œ Middleware to parse form-data and handle file upload
app.post('/submit', upload.single('validId'), async (req, res) => {
  const { lastName, firstName, middleName, birthday, contactNumber, address, dataRegistered } = req.body;
  const validIdFileName = req.file ? req.file.filename : 'No file uploaded';

  try {
    const pool = await connectToDatabase();
    const currentYear = new Date().getFullYear();

    // Check if the client already exists based on fname, mname, and lname
    const existingClient = await pool.request()
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('lastName', mssql.NVarChar, lastName)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE fname = @firstName AND mname = @middleName AND lname = @lastName
      `);

    if (existingClient.recordset.length > 0) {
      // Client already exists, generate JWT token with existing clientId
      const clientId = existingClient.recordset[0].client_id;
      const token = jwt.sign(
        { clientId, firstName, lastName },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
      );

      return res.status(200).json({ message: 'Client already exists', clientId, token });
    }

    // Get the highest client_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE client_id LIKE CONCAT(@currentYear, '%')
        ORDER BY client_id DESC
      `);

    let clientId = `${currentYear}01`;

    if (result.recordset.length > 0) {
      const lastClientId = result.recordset[0].client_id;
      const newIdNumber = parseInt(lastClientId.slice(-2), 10) + 1;
      clientId = `${currentYear}${String(newIdNumber).padStart(2, '0')}`;
    }

    // Insert new client data if client does not exist
    await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('lastName', mssql.NVarChar, lastName)
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('birthday', mssql.NVarChar, birthday)
      .input('contactNumber', mssql.NVarChar, contactNumber)
      .input('address', mssql.NVarChar, address)
      .input('validIdFileName', mssql.NVarChar, validIdFileName)
      .input('dataRegistered', mssql.NVarChar, dataRegistered)
      .query(`
        INSERT INTO client_info (client_id, lname, fname, mname, bday, cont_num, address, valid_id, reg_date)
        VALUES (@clientId, @lastName, @firstName, @middleName, @birthday, @contactNumber, @address, @validIdFileName, @dataRegistered)
      `);

    // Generate JWT Token for new client
    const token = jwt.sign(
      { clientId, firstName, lastName },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    res.status(200).json({ message: 'Data inserted successfully!', clientId, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Error inserting data into the database.' });
  }
});



// The route to handle loan submissions
app.post('/submit-loan', async (req, res) => {
  // Destructure the required data from the request body
  const { clientId, loanAmount, loanInterest, noOfMonths, loanDate, total, biWeeklyAmortization } = req.body;

  try {
    // Log the request body to check if loanAmount has a value
    console.log('Request Body:', req.body);
    
    const pool = await mssql.connect(sqlConfig);

    // Generate loan reference number (loanRefNo) with the current year and incrementing number
    const currentYear = new Date().getFullYear();
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 LoanRefNo
        FROM Loans
        WHERE LoanRefNo LIKE '${currentYear}%'
        ORDER BY LoanRefNo DESC
      `);

    let loanRefNo = `${currentYear}0001`;  // Default to the first loan of the year

    if (result.recordset.length > 0) {
      const lastLoanRefNo = result.recordset[0].LoanRefNo; // Ensure correct column name (case-sensitive)
      
      if (lastLoanRefNo) {
        const newRefNo = parseInt(lastLoanRefNo.slice(-4)) + 1;
        loanRefNo = `${currentYear}${String(newRefNo).padStart(4, '0')}`;
      } else {
        console.error('No valid loanRefNo found');
        loanRefNo = `${currentYear}0001`; // Reset if the reference number is invalid
      }
    }
    const noOfTerms =  noOfMonths *2;
    const status = 'Waiting for Approval';
    const notReleased = 'No';
    // Insert the loan data into the loan table
    const resultInsert = await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('loanRefNo', mssql.NVarChar, loanRefNo)
      .input('loanAmount', mssql.Float, loanAmount)
      .input('loanInterest', mssql.Int, loanInterest)
      .input('noOfMonths', mssql.Int, noOfMonths)
      .input('loanDate', mssql.Date, loanDate)  // Insert the loan date
      .input('total', mssql.Float, total)
      .input('biWeeklyAmortization', mssql.Float, biWeeklyAmortization)
      .input('noOfTerms',mssql.Int, noOfTerms)
      .input('onGoing', mssql.NVarChar, status)
      .input('notReleased', mssql.NVarChar, notReleased)
      .query(`
        INSERT INTO Loans (LoanRefNo, client_id, LoanAmount, interest, noOfMonths, LoanDate, TotalAmount,biWeeklyPay,running_balance,no_of_terms,status,isReleased)
        VALUES (@loanRefNo, @clientId, @loanAmount, @loanInterest, @noOfMonths, @loanDate, @total, @biWeeklyAmortization, @total, @noOfTerms,@onGoing,@notReleased)
      `);

    // Return response with the token
    res.status(200).json({
      message: 'Loan data inserted successfully!',loanRefNo});
  } catch (err) {
    console.error('Error inserting loan data:', err);
    res.status(500).json({ message: 'Error inserting loan data.' });
  }
});




app.get('/loanData', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1]; // Assuming Bearer token format
  if (!token) {
    return res.status(400).send('Token missing');
  }

  const decodedToken = jwtDecode(token);
  const { loanRefNo, clientId } = decodedToken;
  const status = 'On Going';
  try {
    const pool = await mssql.connect(sqlConfig); // Ensure that sqlConfig is defined and correct
    const result = await pool.request() // Corrected query using pool.request()
      .input('loanRefNo', mssql.NVarChar, loanRefNo) // Use parameterized queries for security
      .input('clientId', mssql.NVarChar, clientId)
      .input('onGoing', mssql.NVarChar, status)
      .query(`
        SELECT LoanRefNo, client_id, LoanAmount, TotalAmount, noOfMonths, LoanDate, interest, biWeeklyPay,running_balance 
        FROM Loans 
        WHERE LoanRefNo = @loanRefNo AND client_id = @clientId AND status = @onGoing
      `);

    if (result.recordset.length > 0) {
      res.json(result.recordset[0]); // Send loan data back
    } else {
      res.status(404).send('Loan not found');
    }
  } catch (error) {
    console.error('Database query error', error);
    res.status(500).send('Internal server error');
  }
});


// Insert payment and update loan balance
app.post('/make-payment', async (req, res) => {
  const { loanRefNo, paymentDate, payment } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    // Get the current year
    const currentYear = new Date().getFullYear();

    // Query the latest PaymentID for the current year to get the last series number
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID
        FROM Payments
        WHERE PaymentID LIKE '${currentYear}%'
        ORDER BY PaymentID DESC
      `);

    // Generate the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastPaymentID = result.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }

    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, '0')}`;

    // Insert payment into Payments table
    await pool.request()
      .input('PaymentID', mssql.NVarChar, nextPaymentID)
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .input('PaymentDate', mssql.DateTime, paymentDate)
      .query(`
        INSERT INTO Payments (PaymentID, LoanRefNo, PaymentAmount, PaymentDate)
        VALUES (@PaymentID, @LoanRefNo, @PaymentAmount, @PaymentDate)
      `);

    // Update the loan balance by reducing it with the payment amount
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .query(`
        UPDATE Loans
        SET running_balance = running_balance - @PaymentAmount
        WHERE LoanRefNo = @LoanRefNo
      `);

    // Get the updated loan information to return
    const updatedLoan = await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .query(`
        SELECT running_balance, TotalAmount, biWeeklyPay
        FROM Loans
        WHERE LoanRefNo = @LoanRefNo
      `);

    const updatedData = updatedLoan.recordset[0];
    if (updatedData.running_balance <= 0) {
      await pool.request()
        .input('fullyPaid', mssql.NVarChar, 'Fully Paid')
        .input('LoanRefNo', mssql.Int, loanRefNo)
        .query(`
          UPDATE Loans
          SET status = @fullyPaid
          WHERE LoanRefNo = @LoanRefNo
        `);
    }
    res.status(200).json({
      updatedLoanAmount: updatedData.running_balance,
      updatedTotalAmount: updatedData.TotalAmount,
      updatedbiWeeklyAmount: updatedData.biWeeklyPay,
      message: 'Payment recorded and loan balance updated successfully.'
    });

  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ message: 'Error processing payment.' });
  }
});


app.get('/PendingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.LoanDate, l.LoanAmount, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status IN ('Waiting for Approval', 'Approved')
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      date: row.LoanDate,
      status: row.status,
      amount: row.LoanAmount,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.post('/submitLoanApprovals', async (req, res) => {
  const { loanId, approvedDate, approvers } = req.body; // approvers is an array

  if (!Array.isArray(approvers) || approvers.length === 0) {
    return res.status(400).json({ success: false, message: "Approvers list is empty or invalid." });
  }

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // Query the latest approved_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 approved_id
        FROM approvers
        WHERE approved_id LIKE '${currentYear}%'
        ORDER BY approved_id DESC
      `);

    // Determine the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastApprovedID = result.recordset[0].approved_id; // Correct column reference
      nextSeries = parseInt(lastApprovedID.slice(-6)) + 1;
    }

    // Insert each approver as a new row
    for (let i = 0; i < approvers.length; i++) {
      const nextApproverID = `${currentYear}${String(nextSeries + i).padStart(6, '0')}`;

      await pool.request()
        .input('ApprovedId', mssql.NVarChar, nextApproverID)
        .input('LoanRefNo', mssql.Int, loanId)
        .input('Date', mssql.Date, approvedDate)
        .input('Approver', mssql.NVarChar, approvers[i]) // Insert individual approver
        .query(`
          INSERT INTO approvers (approved_id, LoanRefNo, approvedDate, approver_name)
          VALUES (@ApprovedId, @LoanRefNo, @Date, @Approver)
        `);
    }

    // Update the status of the loan to "Approved"
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanId)
      .query(`
        UPDATE Loans
        SET status = 'Approved'
        WHERE LoanRefNo = @LoanRefNo
      `);

    res.status(200).json({ success: true, message: 'Loan approval submitted successfully.' });

  } catch (error) {
    console.error('Error processing loan approval:', error);
    return res.status(500).json({ success: false, message: 'Internal server error.' });
  }
});

app.get('/fetchApprovers/:loanId', async (req, res) => {
  const loanId = req.params.loanId;  // Get loanId from URL params

  try {
    // Query the database for approvers related to the loanId
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId) // Assuming loanId is an integer
      .query('SELECT approver_name FROM approvers WHERE LoanRefNo = @loanId');  // Your query to fetch approvers

    if (result.recordset.length > 0) {
      // If approvers are found, send them as the response
      res.json({
        success: true,
        approvers: result.recordset.map(row => ({
          name: row.approver_name,  // Assuming the column in the database is `approver_name`
        })),
      });
    }
  } catch (err) {
    console.error('Error fetching approvers:', err);
    res.status(500).json({ success: false, message: 'Error fetching approvers' });
  }
});

app.get('/pendingCount', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
    res.json({ count: result.recordset[0].count });
  } catch (error) {
    console.error('Error fetching pending loans:', error);
    res.status(500).send('Internal Server Error');
  }
});

const clients = new Set();
wss.on('connection', (ws) => {
  console.log('New client connected');
  clients.add(ws);

  // Function to send counts to all connected clients
  const sendLoanCounts = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query(`
        SELECT 
          (SELECT COUNT(*) FROM Loans WHERE status = 'Waiting for Approval') AS pendingCount,
          (SELECT COUNT(*) FROM Loans WHERE status = 'Released') AS releasedCount
      `);
      
      const counts = {
        type: 'loanCounts',
        pendingCount: result.recordset[0].pendingCount,
        releasedCount: result.recordset[0].releasedCount
      };

      // Broadcast to all connected clients
      clients.forEach(client => {
        if (client.readyState === client.OPEN) {
          client.send(JSON.stringify(counts));
        }
      });

    } catch (error) {
      console.error('Error fetching loan counts:', error);
    }
  };

  // Send initial data immediately when the client connects
  sendLoanCounts();

  // Set up an interval to update all clients every 10 seconds
  const intervalId = setInterval(sendLoanCounts, 10000);

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
    clients.delete(ws);
    if (clients.size === 0) {
      clearInterval(intervalId); // Stop the interval if no clients are connected
    }
  });
});

app.post('/releaseLoan', async (req, res) => {
  const { loanId, releasedBy, releasedDate , PaymentStartAt} = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    console.log('releasedBy:', releasedBy);
    // Update the loan status to Released and set other fields
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('releasedBy', mssql.NVarChar, releasedBy) 
      .input('releasedDate', mssql.Date, releasedDate)
      .input('PaymentStartAt', mssql.Date, PaymentStartAt)
      .query(`
        UPDATE Loans
        SET isReleased = 'Yes', status = 'Released', releasedBy = @releasedBy, releasedWhen = @releasedDate, PaymentStartAt = @PaymentStartAt
        WHERE LoanRefNo = @loanId
      `);

    res.status(200).json({ message: 'Loan Released successfully!' });

  } catch (err) {
    console.error('Error releasing loan:', err);
    res.status(500).json({ message: 'Error releasing loan.' });
  }
});

// Start the server
app.listen(port, async () => {
  await connectToDatabase(); // Ensure database is connected before accepting requests
  console.log(`Server running on port ${port}`);
});



const express = require('express');
const multer = require('multer');
const mssql = require('mssql');
const WebSocket = require('ws');
const path = require('path');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config({ path: '../.env.development' }); // Load .env file
const jwtDecode = require('jwt-decode');
// Set up express app
const app = express();
const port = 5000;
const wss = new WebSocket.Server({ port: 8080 });
// Enable CORS
app.use(cors()); // Allow all origins
app.use(express.json());
// Multer Storage Configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const { firstName, lastName } = req.body;
    const fileExtension = path.extname(file.originalname);
    cb(null, `${firstName}${lastName}(ValidID)${fileExtension}`);
  }
});

const upload = multer({ storage });

// MSSQL Configuration
const sqlConfig = {
  user: 'sa',
  password: 'Eugene12042001',
  server: 'LAPTOP-NI-POGI',
  database: 'NEMPA',
  options: {
    instanceName: "SQLEXPRESS",
    encrypt: false,
    trustServerCertificate: true,
  },
  connectionTimeout: 15000,
  requestTimeout: 15000,
};

// Create a connection pool once
let pool;

async function connectToDatabase() {
  if (!pool) {
    try {
      pool = await mssql.connect(sqlConfig);
      console.log('Connected to the database successfully');
    } catch (err) {
      console.error('Database connection failed:', err);
      process.exit(1); // Exit if connection fails
    }
  }
  return pool;
}

// ðŸ“Œ Middleware to parse form-data and handle file upload
app.post('/submit', upload.single('validId'), async (req, res) => {
  const { lastName, firstName, middleName, birthday, contactNumber, address, dataRegistered } = req.body;
  const validIdFileName = req.file ? req.file.filename : 'No file uploaded';

  try {
    const pool = await connectToDatabase();
    const currentYear = new Date().getFullYear();

    // Check if the client already exists based on fname, mname, and lname
    const existingClient = await pool.request()
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('lastName', mssql.NVarChar, lastName)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE fname = @firstName AND mname = @middleName AND lname = @lastName
      `);

    if (existingClient.recordset.length > 0) {
      // Client already exists, generate JWT token with existing clientId
      const clientId = existingClient.recordset[0].client_id;
      const token = jwt.sign(
        { clientId, firstName, lastName },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
      );

      return res.status(200).json({ message: 'Client already exists', clientId, token });
    }

    // Get the highest client_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 client_id FROM client_info
        WHERE client_id LIKE CONCAT(@currentYear, '%')
        ORDER BY client_id DESC
      `);

    let clientId = `${currentYear}01`;

    if (result.recordset.length > 0) {
      const lastClientId = result.recordset[0].client_id;
      const newIdNumber = parseInt(lastClientId.slice(-2), 10) + 1;
      clientId = `${currentYear}${String(newIdNumber).padStart(2, '0')}`;
    }

    // Insert new client data if client does not exist
    await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('lastName', mssql.NVarChar, lastName)
      .input('firstName', mssql.NVarChar, firstName)
      .input('middleName', mssql.NVarChar, middleName)
      .input('birthday', mssql.NVarChar, birthday)
      .input('contactNumber', mssql.NVarChar, contactNumber)
      .input('address', mssql.NVarChar, address)
      .input('validIdFileName', mssql.NVarChar, validIdFileName)
      .input('dataRegistered', mssql.NVarChar, dataRegistered)
      .query(`
        INSERT INTO client_info (client_id, lname, fname, mname, bday, cont_num, address, valid_id, reg_date)
        VALUES (@clientId, @lastName, @firstName, @middleName, @birthday, @contactNumber, @address, @validIdFileName, @dataRegistered)
      `);

    // Generate JWT Token for new client
    const token = jwt.sign(
      { clientId, firstName, lastName },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    res.status(200).json({ message: 'Data inserted successfully!', clientId, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Error inserting data into the database.' });
  }
});



// The route to handle loan submissions
app.post('/submit-loan', async (req, res) => {
  // Destructure the required data from the request body
  const { clientId, loanAmount, loanInterest, noOfMonths, loanDate, total, biWeeklyAmortization } = req.body;

  try {
    // Log the request body to check if loanAmount has a value
    console.log('Request Body:', req.body);
    
    const pool = await mssql.connect(sqlConfig);

    // Generate loan reference number (loanRefNo) with the current year and incrementing number
    const currentYear = new Date().getFullYear();
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 LoanRefNo
        FROM Loans
        WHERE LoanRefNo LIKE '${currentYear}%'
        ORDER BY LoanRefNo DESC
      `);

    let loanRefNo = `${currentYear}0001`;  // Default to the first loan of the year

    if (result.recordset.length > 0) {
      const lastLoanRefNo = result.recordset[0].LoanRefNo; // Ensure correct column name (case-sensitive)
      
      if (lastLoanRefNo) {
        const newRefNo = parseInt(lastLoanRefNo.slice(-4)) + 1;
        loanRefNo = `${currentYear}${String(newRefNo).padStart(4, '0')}`;
      } else {
        console.error('No valid loanRefNo found');
        loanRefNo = `${currentYear}0001`; // Reset if the reference number is invalid
      }
    }
    const noOfTerms =  noOfMonths *2;
    const status = 'Waiting for Approval';
    const notReleased = 'No';
    // Insert the loan data into the loan table
    const resultInsert = await pool.request()
      .input('clientId', mssql.NVarChar, clientId)
      .input('loanRefNo', mssql.NVarChar, loanRefNo)
      .input('loanAmount', mssql.Float, loanAmount)
      .input('loanInterest', mssql.Int, loanInterest)
      .input('noOfMonths', mssql.Int, noOfMonths)
      .input('loanDate', mssql.Date, loanDate)  // Insert the loan date
      .input('total', mssql.Float, total)
      .input('biWeeklyAmortization', mssql.Float, biWeeklyAmortization)
      .input('noOfTerms',mssql.Int, noOfTerms)
      .input('onGoing', mssql.NVarChar, status)
      .input('notReleased', mssql.NVarChar, notReleased)
      .query(`
        INSERT INTO Loans (LoanRefNo, client_id, LoanAmount, interest, noOfMonths, LoanDate, TotalAmount,biWeeklyPay,running_balance,no_of_terms,status,isReleased)
        VALUES (@loanRefNo, @clientId, @loanAmount, @loanInterest, @noOfMonths, @loanDate, @total, @biWeeklyAmortization, @total, @noOfTerms,@onGoing,@notReleased)
      `);

    // Return response with the token
    res.status(200).json({
      message: 'Loan data inserted successfully!',loanRefNo});
  } catch (err) {
    console.error('Error inserting loan data:', err);
    res.status(500).json({ message: 'Error inserting loan data.' });
  }
});




app.get('/loanData', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1]; // Assuming Bearer token format
  if (!token) {
    return res.status(400).send('Token missing');
  }

  const decodedToken = jwtDecode(token);
  const { loanRefNo, clientId } = decodedToken;
  const status = 'On Going';
  try {
    const pool = await mssql.connect(sqlConfig); // Ensure that sqlConfig is defined and correct
    const result = await pool.request() // Corrected query using pool.request()
      .input('loanRefNo', mssql.NVarChar, loanRefNo) // Use parameterized queries for security
      .input('clientId', mssql.NVarChar, clientId)
      .input('onGoing', mssql.NVarChar, status)
      .query(`
        SELECT LoanRefNo, client_id, LoanAmount, TotalAmount, noOfMonths, LoanDate, interest, biWeeklyPay,running_balance 
        FROM Loans 
        WHERE LoanRefNo = @loanRefNo AND client_id = @clientId AND status = @onGoing
      `);

    if (result.recordset.length > 0) {
      res.json(result.recordset[0]); // Send loan data back
    } else {
      res.status(404).send('Loan not found');
    }
  } catch (error) {
    console.error('Database query error', error);
    res.status(500).send('Internal server error');
  }
});


// Insert payment and update loan balance
app.post('/make-payment', async (req, res) => {
  const { loanRefNo, paymentDate, payment } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    // Get the current year
    const currentYear = new Date().getFullYear();

    // Query the latest PaymentID for the current year to get the last series number
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 PaymentID
        FROM Payments
        WHERE PaymentID LIKE '${currentYear}%'
        ORDER BY PaymentID DESC
      `);

    // Generate the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastPaymentID = result.recordset[0].PaymentID;
      nextSeries = parseInt(lastPaymentID.slice(-6)) + 1;
    }

    const nextPaymentID = `${currentYear}${String(nextSeries).padStart(6, '0')}`;

    // Insert payment into Payments table
    await pool.request()
      .input('PaymentID', mssql.NVarChar, nextPaymentID)
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .input('PaymentDate', mssql.DateTime, paymentDate)
      .query(`
        INSERT INTO Payments (PaymentID, LoanRefNo, PaymentAmount, PaymentDate)
        VALUES (@PaymentID, @LoanRefNo, @PaymentAmount, @PaymentDate)
      `);

    // Update the loan balance by reducing it with the payment amount
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .input('PaymentAmount', mssql.Decimal(18, 2), payment)
      .query(`
        UPDATE Loans
        SET running_balance = running_balance - @PaymentAmount
        WHERE LoanRefNo = @LoanRefNo
      `);

    // Get the updated loan information to return
    const updatedLoan = await pool.request()
      .input('LoanRefNo', mssql.Int, loanRefNo)
      .query(`
        SELECT running_balance, TotalAmount, biWeeklyPay
        FROM Loans
        WHERE LoanRefNo = @LoanRefNo
      `);

    const updatedData = updatedLoan.recordset[0];
    if (updatedData.running_balance <= 0) {
      await pool.request()
        .input('fullyPaid', mssql.NVarChar, 'Fully Paid')
        .input('LoanRefNo', mssql.Int, loanRefNo)
        .query(`
          UPDATE Loans
          SET status = @fullyPaid
          WHERE LoanRefNo = @LoanRefNo
        `);
    }
    res.status(200).json({
      updatedLoanAmount: updatedData.running_balance,
      updatedTotalAmount: updatedData.TotalAmount,
      updatedbiWeeklyAmount: updatedData.biWeeklyPay,
      message: 'Payment recorded and loan balance updated successfully.'
    });

  } catch (error) {
    console.error('Error processing payment:', error);
    res.status(500).json({ message: 'Error processing payment.' });
  }
});


app.get('/PendingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.LoanDate, l.LoanAmount, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status IN ('Waiting for Approval', 'Approved')
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      date: row.LoanDate,
      status: row.status,
      amount: row.LoanAmount,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

app.post('/submitLoanApprovals', async (req, res) => {
  const { loanId, approvedDate, approvers } = req.body; // approvers is an array

  if (!Array.isArray(approvers) || approvers.length === 0) {
    return res.status(400).json({ success: false, message: "Approvers list is empty or invalid." });
  }

  try {
    const pool = await mssql.connect(sqlConfig);
    const currentYear = new Date().getFullYear();

    // Query the latest approved_id for the current year
    const result = await pool.request()
      .input('currentYear', mssql.Int, currentYear)
      .query(`
        SELECT TOP 1 approved_id
        FROM approvers
        WHERE approved_id LIKE '${currentYear}%'
        ORDER BY approved_id DESC
      `);

    // Determine the next series number
    let nextSeries = 1;
    if (result.recordset.length > 0) {
      const lastApprovedID = result.recordset[0].approved_id; // Correct column reference
      nextSeries = parseInt(lastApprovedID.slice(-6)) + 1;
    }

    // Insert each approver as a new row
    for (let i = 0; i < approvers.length; i++) {
      const nextApproverID = `${currentYear}${String(nextSeries + i).padStart(6, '0')}`;

      await pool.request()
        .input('ApprovedId', mssql.NVarChar, nextApproverID)
        .input('LoanRefNo', mssql.Int, loanId)
        .input('Date', mssql.Date, approvedDate)
        .input('Approver', mssql.NVarChar, approvers[i]) // Insert individual approver
        .query(`
          INSERT INTO approvers (approved_id, LoanRefNo, approvedDate, approver_name)
          VALUES (@ApprovedId, @LoanRefNo, @Date, @Approver)
        `);
    }

    // Update the status of the loan to "Approved"
    await pool.request()
      .input('LoanRefNo', mssql.Int, loanId)
      .query(`
        UPDATE Loans
        SET status = 'Approved'
        WHERE LoanRefNo = @LoanRefNo
      `);

    res.status(200).json({ success: true, message: 'Loan approval submitted successfully.' });

  } catch (error) {
    console.error('Error processing loan approval:', error);
    return res.status(500).json({ success: false, message: 'Internal server error.' });
  }
});

app.get('/fetchApprovers/:loanId', async (req, res) => {
  const loanId = req.params.loanId;  // Get loanId from URL params

  try {
    // Query the database for approvers related to the loanId
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId) // Assuming loanId is an integer
      .query('SELECT approver_name FROM approvers WHERE LoanRefNo = @loanId');  // Your query to fetch approvers

    if (result.recordset.length > 0) {
      // If approvers are found, send them as the response
      res.json({
        success: true,
        approvers: result.recordset.map(row => ({
          name: row.approver_name,  // Assuming the column in the database is `approver_name`
        })),
      });
    }
  } catch (err) {
    console.error('Error fetching approvers:', err);
    res.status(500).json({ success: false, message: 'Error fetching approvers' });
  }
});

wss.on('connection', (ws) => {
  console.log('New client connected');

  // Send initial pending count
  const sendPendingCount = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
      ws.send(JSON.stringify({ type: 'pendingCount', count: result.recordset[0].count }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  };

  sendPendingCount();  // Send initial data when the client connects

  // Simulate the pending loans count update every 10 seconds
  setInterval(async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Waiting for Approval'");
      const pendingCount = result.recordset[0].count;

      // Send the updated count to the client
      ws.send(JSON.stringify({ type: 'pendingCount', count: pendingCount }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  }, 10000);  // Update every 10 seconds

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

wss.on('connection', (ws) => {
  console.log('New client connected');

  // Send initial pending count
  const sendPendingCount = async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Released'");
      ws.send(JSON.stringify({ type: 'pendingCount', count: result.recordset[0].count }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  };

  sendPendingCount();  // Send initial data when the client connects

  // Simulate the pending loans count update every 10 seconds
  setInterval(async () => {
    try {
      const pool = await mssql.connect(sqlConfig);
      const result = await pool.request().query("SELECT COUNT(*) as count FROM Loans WHERE status = 'Released'");
      const releasedCount = result.recordset[0].count;

      // Send the updated count to the client
      ws.send(JSON.stringify({ type: 'releasedCount', count: releasedCount }));
    } catch (error) {
      console.error('Error fetching pending loans count:', error);
    }
  }, 10000);  // Update every 10 seconds

  // Clean up when the client disconnects
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

app.post('/releaseLoan', async (req, res) => {
  const { loanId, releasedBy, releasedDate, PaymentStartAt } = req.body;

  try {
    const pool = await mssql.connect(sqlConfig);

    console.log('releasedBy:', releasedBy);
    // Update the loan status to Released and set other fields
    const result = await pool.request()
      .input('loanId', mssql.NVarChar, loanId)
      .input('releasedBy', mssql.NVarChar, releasedBy) 
      .input('releasedDate', mssql.Date, releasedDate)
      .input('PaymentStartAt', mssql.Date, PaymentStartAt)
      .query(`
        UPDATE Loans
        SET isReleased = 'Yes', status = 'Released', releasedBy = @releasedBy, releasedWhen = @releasedDate, PaymentStartAt = @PaymentStartAt
        WHERE LoanRefNo = @loanId
      `);

    res.status(200).json({ message: 'Loan Released successfully!' });

  } catch (err) {
    console.error('Error releasing loan:', err);
    res.status(500).json({ message: 'Error releasing loan.' });
  }
});

app.get('/OnGoingLoans', async (req, res) => {
  try {
    const pool = await mssql.connect(sqlConfig);
    const result = await pool.request()
      .query(`
        SELECT l.LoanRefNo, l.biWeeklyPay, l.running_balance, l.PaymentStartAt, l.status, c.fname, c.lname
        FROM Loans l
        JOIN client_info c ON l.client_id = c.client_id
        WHERE l.status = 'Released'
      `);

    const loans = result.recordset.map(row => ({
      id: row.LoanRefNo, // Use LoanRefNo as the id
      dueDate: row.PaymentStartAt,
      biWeeklyPay: row.biWeeklyPay,
      amount: row.running_balance,
      status: row.status,
      customer: {
        name: `${row.fname} ${row.lname}`,
      }
    }));

    res.json(loans); // Send the loans data back as JSON
  } catch (err) {
    console.error('Database query failed', err);
    res.status(500).send('Error retrieving data from database');
  }
});

// Start the server
app.listen(port, async () => {
  await connectToDatabase(); // Ensure database is connected before accepting requests
  console.log(`Server running on port ${port}`);
});


import * as React from 'react';
import AddCardIcon from '@mui/icons-material/AddCard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import { AppProvider } from '@toolpad/core/AppProvider';
import { DashboardLayout } from '@toolpad/core/DashboardLayout';
import { PageContainer } from '@toolpad/core/PageContainer';
import Grid from '@mui/material/Grid2';
import Stack from '@mui/material/Stack';
import Chip from '@mui/material/Chip';
import Typography from '@mui/material/Typography';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { useDemoRouter } from '@toolpad/core/internal';
import { useState, useEffect, useRef } from 'react';
// Pages
import Loan from './Checkout';
import PendingLoan from './PendingLoans';
import OnGoingLoan from './OnGoing';
import Dashboard from './Dashboard';
// Theme setup
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b', // Teal green
    },
    background: {
      paper: '#ffffff',
    },
  },
});

const DashboardLayoutBasic = () => {
  const [pendingLoansCount, setPendingLoansCount] = useState(0);
  const router = useDemoRouter('/dashboard');
  const [releasedLoansCount, setReleasedLoansCount] = useState(0);
  const wsRef = useRef(null);
  const reconnectAttempts = useRef(0);

  useEffect(() => {
    const connectWebSocket = () => {
      if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) {
        return; // Prevent duplicate connections
      }

      wsRef.current = new WebSocket("ws://localhost:8080");

      wsRef.current.onopen = () => {
        console.log("WebSocket connected");
        reconnectAttempts.current = 0; // Reset reconnect attempts
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === "loanCounts") {
            setPendingLoansCount(data.pendingCount);
            setReleasedLoansCount(data.releasedCount);
          }
        } catch (error) {
          console.error("Error parsing WebSocket message:", error);
        }
      };

      // wsRef.current.onerror = (error) => {
      //   console.error("WebSocket error:", error);
      // };

      wsRef.current.onclose = () => {
        console.log("WebSocket disconnected, attempting to reconnect...");

        if (reconnectAttempts.current < 5) { // Limit reconnection attempts
          reconnectAttempts.current += 1;
          setTimeout(connectWebSocket, 5000); // ðŸ”„ Retry after 5 seconds
        } else {
          console.error("Max reconnect attempts reached. WebSocket stopped.");
        }
      };
    };

    connectWebSocket();

    return () => wsRef.current && wsRef.current.close();
  }, []);


  // Function to render the correct page based on pathname
  function renderPage() {
    const { pathname } = router;
    switch (pathname) {
      case '/dashboard':
        return <Dashboard />;
      case '/loanApplication':
        return <Loan />;
      case '/loans/Pending':
        return <PendingLoan />;
      case '/loans/OnGoing':
        return <OnGoingLoan/>;
      default:
        return <Dashboard />;
    }
  }

  // Navigation setup
  const NAVIGATION = [
    {
      segment: 'dashboard',
      title: 'Dashboard',
      icon: <DashboardIcon />,
      component: <Dashboard />,
    },
    {
      segment: 'loans',
      title: 'Loans',
      icon: <AccountBalanceIcon />,
      children: [
        {
          segment: 'Pending',
          title: 'Pending Loans',
          icon: <PendingActionsIcon />,
          action: (
            <Chip
              label={pendingLoansCount}
              color="warning"
              style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
            />
          ),
          route: '/loans/Pending',
          component: <PendingLoan />,
        },
        {
          segment: 'OnGoing',
          title: 'On Going Loans',
          icon: <AssuredWorkloadIcon />,
          action: (
            <Chip
              label={releasedLoansCount}
              color="warning"
              style={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold' }}
            />
          ),
          route: '/loans/OnGoing',
          component: <OnGoingLoan />,
        },
        {
          segment: 'Paid',
          title: 'Paid Loans',
          icon: <CreditScoreIcon />,
          route: '/loans/Paid',
        },
      ],
    },
    {
      segment: 'loanApplication',
      title: 'Loan Application',
      icon: <AddCardIcon />,
      route: '/loanApplication',
      component: <Loan />,
    },
    {
      segment: 'transactionhistory',
      title: 'Transaction History',
      icon: <ReceiptLongIcon />,
      route: '/integrations',
    },
  ];

  // Custom header for the app title
  function CustomAppTitle() {
    return (
      <Stack direction="row" alignItems="center" spacing={2}>
        <Typography variant="h6">Loan Application</Typography>
      </Stack>
    );
  }

  return (
    <AppProvider navigation={NAVIGATION} router={router} theme={theme}>
      <DashboardLayout
      disableCollapsibleSidebar
        slots={{
          appTitle: CustomAppTitle,
        }}
      >
        <PageContainer sx={{ paddingTop: 1, paddingBottom: 3 }}>
              {renderPage()}
        </PageContainer>
      </DashboardLayout>
    </AppProvider>
  );
};

export default DashboardLayoutBasic;




import React, { useEffect, useState, useCallback } from 'react';
import { Box, Table, Typography, List, ListItem, Sheet, useTheme, Input } from '@mui/joy';
import useMediaQuery from '@mui/material/useMediaQuery';

const LoanDetails = () => {
    const [loanData, setLoanData] = useState([]);
    const [searchTerm, setSearchTerm] = useState('');
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    useEffect(() => {
        async function fetchLoanDetails() {
            try {
                const response = await fetch('http://localhost:5000/fetch-all-loan-details');
                const data = await response.json();
                setLoanData(data);
                console.log(data); // For debugging purposes
            } catch (error) {
                console.error('Error fetching loan details:', error);
            }
        }

        fetchLoanDetails();
    }, []);

    const filteredLoanData = useCallback(() => {
        return loanData.filter(loan =>
            loan.LoanRefNo.toLowerCase().includes(searchTerm.toLowerCase()) ||
            loan.ReleasedBy.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [loanData, searchTerm]);

    const renderMobileView = useCallback(() => (
        <>
            <Box sx={{ mb: 2 }}>
                <Input
                    placeholder="Search by reference number or released by..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    fullWidth
                    variant="outlined"
                    sx={{
                        borderRadius: '8px',
                        mb: 3,
                        bgcolor: 'background.level1',
                        '& input': { p: 1 },
                    }}
                />
            </Box>
            <List sx={{ p: 0 }}>
                {filteredLoanData().length > 0 ? (
                    filteredLoanData().flatMap(loan =>
                        loan.Payments.map((payment, index) => (
                            <ListItem
                                key={`${loan.LoanRefNo}-${index}`}
                                sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    gap: 2,
                                    mb: 3,
                                    bgcolor: 'background.level2',
                                    borderRadius: 'md',
                                    p: 3,
                                    boxShadow: 2,
                                }}
                            >
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Reference No:</Typography>
                                    <Typography>{loan.LoanRefNo}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Payment Amount:</Typography>
                                    <Typography>â‚±{payment.PaymentAmount?.toLocaleString()}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Payment Date:</Typography>
                                    <Typography>{payment.PaymentDate}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Status:</Typography>
                                    <Typography>{loan.Status === 'Released' ? 'On Going' : loan.Status}</Typography>
                                </Box>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                    <Typography level="body-sm" sx={{ color: 'text.secondary' }}>Released By:</Typography>
                                    <Typography>{loan.ReleasedBy}</Typography>
                                </Box>
                            </ListItem>
                        ))
                    )
                ) : (
                    <Typography textAlign="center" sx={{ color: 'text.tertiary' }}>No transactions found</Typography>
                )}
            </List>
        </>
    ), [loanData, searchTerm]);

    const renderDesktopView = useCallback(() => (
        <>
            <Box sx={{ mb: 2 }}>
                <Input
                    placeholder="Search by reference number or released by..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    fullWidth
                    variant="outlined"
                    sx={{
                        borderRadius: '8px',
                        mb: 3,
                        bgcolor: 'background.level1',
                        '& input': { p: 1 },
                    }}
                />
            </Box>
            <Table sx={{ borderCollapse: 'separate', borderSpacing: 2 }}>
                <thead style={{ backgroundColor: "#212529" }}>
                    <tr>
                        {[
                            "Reference Number",
                            "Loan Amount",
                            "Interest Rate", 
                            "Total Amount Paid",
                            "Client Name",
                            "Payment Status",
                            "Date"
                        ].map((header, index) => (
                            <th
                                key={index}
                                style={{
                                    padding: "12px 16px",
                                    color: "white",
                                    backgroundColor: "#212529",
                                    textAlign: "center"
                                }}
                            >
                                <Typography
                                    variant="body-sm"
                                    sx={{
                                        textAlign: "center",
                                        display: "block",
                                        color: "inherit"
                                    }}
                                >
                                    {header}
                                </Typography>
                            </th>
                        ))}
                    </tr>
                </thead>
                <tbody>
                    {filteredLoanData().length > 0 ? (
                        filteredLoanData().map(loan => (
                            loan.Payments.map((payment, index) => (
                                <tr key={`${loan.LoanRefNo}-${index}`}>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{loan.LoanRefNo}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>â‚±{payment.PaymentAmount?.toLocaleString()}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>1%</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>â‚±{loan.TotalAmountPaid?.toLocaleString()}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{loan.ReleasedBy}</td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>
                                        {loan.Status === 'Released' ? 'On Going' : loan.Status}
                                    </td>
                                    <td style={{ padding: '12px 16px', textAlign: 'center' }}>{payment.PaymentDate}</td>
                                </tr>
                            ))
                        ))
                    ) : (
                        <tr>
                            <td colSpan={7} style={{ textAlign: 'center', padding: '16px' }}>
                                <Typography sx={{ color: 'text.tertiary' }}>No transactions found</Typography>
                            </td>
                        </tr>
                    )}
                </tbody>
            </Table>
        </>
    ), [loanData, searchTerm, theme]);

    return (
        <Box sx={{ p: { xs: 2, sm: 4 }, bgcolor: 'background.default' }}>
            <Typography level="h4" sx={{ mb: 4, fontWeight: 'bold' }}>Transaction History</Typography>
            {isMobile ? renderMobileView() : renderDesktopView()}
        </Box>
    );
};

export default LoanDetails;


  const response = await fetch("http://localhost:5000/PayRecomputedLoan", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ loanId, recomputedAmount, recomputeInterestValue, recomputeDate, dateNow, status, balance, startOfPayment})
      });
      const data = await response.json();
      if(response.ok){
        toast.success(data.message || "Recomputed successfully!", { autoClose: 2000, containerId: 'main-toast' });
        fetchLoans();
      }else{
        toast.error(data.message || "An error occurred while recomputing.", { autoClose: 2000, containerId: 'main-toast' });
      }




      import * as React from 'react';
import AddCardIcon from '@mui/icons-material/AddCard';
import DashboardIcon from '@mui/icons-material/Dashboard';
import AssuredWorkloadIcon from '@mui/icons-material/AssuredWorkload';
import CreditScoreIcon from '@mui/icons-material/CreditScore';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import ReceiptLongIcon from '@mui/icons-material/ReceiptLong';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import MenuIcon from '@mui/icons-material/Menu';
import LogoutRoundedIcon from '@mui/icons-material/LogoutRounded';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import Slide from '@mui/material/Slide';
import { 
  Box, 
  Drawer, 
  List, 
  ListItemIcon, 
  ListItemText, 
  ListItemButton, 
  Collapse, 
  AppBar, 
  Toolbar, 
  Typography, 
  CssBaseline, 
  IconButton, 
  useMediaQuery,
  Chip,
} from '@mui/material';
import { styled, useTheme } from '@mui/material/styles';
import { useState, useEffect, useRef } from 'react';
import ExpandLess from '@mui/icons-material/ExpandLess';
import ExpandMore from '@mui/icons-material/ExpandMore';
import Neeco from '../public/NeecoLogo.svg';
import { createTheme, ThemeProvider } from '@mui/material/styles';

// Pages
import Loan from './Checkout';
import PendingLoan from './PendingLoans';
import OnGoingLoan from './OnGoing';
import Dashboard from './Dashboard';
import PaidLoans from './PaidLoans';
import TransactionHistory from './TransactHistory';
const drawerWidth = 280;

const Main = styled('main', { shouldForwardProp: (prop) => prop !== 'open' })( 
  ({ theme }) => ({
    flexGrow: 1,
    padding: theme.spacing(3),
  })
);

const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="up" ref={ref} {...props} />;
});

const [open, setOpen] = React.useState(false);

const handleClickOpen = () => {
  setOpen(true);
};

const handleClose = () => {
  setOpen(false);
};

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#00796b',
    },
    background: {
      paper: '#ffffff',
    },
  },
});
const name = "Eugene Van Linsangan";
const email = "vaneugene01@gmail.com";
const DashboardLayoutBasic = () => {
  const [pendingLoansCount, setPendingLoansCount] = useState(0);
  const [releasedLoansCount, setReleasedLoansCount] = useState(0);
  const [currentPath, setCurrentPath] = useState('/dashboard');
  const [loansOpen, setLoansOpen] = useState(false);
  const [mobileOpen, setMobileOpen] = useState(false);
  const wsRef = useRef(null);
  const reconnectAttempts = useRef(0);

  const muiTheme = useTheme();
  const isMobile = useMediaQuery(muiTheme.breakpoints.down('sm'));

  useEffect(() => {
    const connectWebSocket = () => {
      if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) return;

      wsRef.current = new WebSocket("ws://localhost:8080");

      wsRef.current.onopen = () => {
        console.log("WebSocket connected");
        reconnectAttempts.current = 0;
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === "loanCounts") {
            setPendingLoansCount(data.pendingCount);
            setReleasedLoansCount(data.releasedCount);
          }
        } catch (error) {
          console.error("Error parsing WebSocket message:", error);
        }
      };

      wsRef.current.onclose = () => {
        console.log("WebSocket disconnected, attempting to reconnect...");
        if (reconnectAttempts.current < 5) {
          reconnectAttempts.current += 1;
          setTimeout(connectWebSocket, 5000);
        } else {
          console.error("Max reconnect attempts reached. WebSocket stopped.");
        }
      };
    };

    connectWebSocket();
    return () => wsRef.current && wsRef.current.close();
  }, []);

  const handleNavigation = (path) => {
    setCurrentPath(path);
    if (isMobile) {
      setMobileOpen(false);
    }
  };

  const handleLoansClick = () => {
    setLoansOpen(!loansOpen);
  };

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const PAGE_COMPONENTS = {
    '/dashboard': <Dashboard />,
    '/loanApplication': <Loan />,
    '/loans/Pending': <PendingLoan />,
    '/loans/OnGoing': <OnGoingLoan />,
    '/loans/Paid': <PaidLoans />,
    '/transactionhistory': <TransactionHistory />,
  };

  const currentPage = PAGE_COMPONENTS[currentPath] || <Dashboard />;

  const drawerContent = (
    <Box sx={{ 
      overflow: 'auto',
      display: 'flex',
      flexDirection: 'column',
      height: '100%',
      backgroundColor: '#EFEFF6',
      padding: '10px',
    }}>
      <List
      sx={{
        marginTop: '10px',
        backgroundColor: '#FCFCFF',
        borderRadius: '10px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        background: 'linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%)',
        padding: '10px',
      }}
      >
        {/* Dashboard Item */}
        <ListItemButton
          onClick={() => handleNavigation('/dashboard')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',  // Reduced padding
            fontSize: '0.8em',  // Smaller font size
            '&:hover': {
              backgroundColor: '#b2dfdb',
            },
            backgroundColor: currentPath === '/dashboard' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <DashboardIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Dashboard" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
  
        {/* Loans Item */}
        <ListItemButton
          onClick={handleLoansClick}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',  // Reduced padding
            fontSize: '0.8em',  // Smaller font size
            '&:hover': {
              backgroundColor: '#b2dfdb',
            },
            backgroundColor: ['/loans/Pending', '/loans/OnGoing', '/loans/Paid'].includes(currentPath) ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <AccountBalanceIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Loans" sx={{ fontSize: '0.8em' }} />
          {loansOpen ? <ExpandLess /> : <ExpandMore />}
        </ListItemButton>
  
        {/* Loans Collapse Items */}
        <Collapse in={loansOpen} timeout="auto" unmountOnExit>
          <List component="div" disablePadding>
            {/* Pending Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/Pending' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }}
              onClick={() => handleNavigation('/loans/Pending')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <PendingActionsIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="Pending Loans" sx={{ fontSize: '0.8em' }} />
              <Chip label={pendingLoansCount} sx={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold', fontSize: '0.75em' }} />
            </ListItemButton>
  
            {/* On Going Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/OnGoing' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }} 
              onClick={() => handleNavigation('/loans/OnGoing')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <AssuredWorkloadIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="On Going Loans" sx={{ fontSize: '0.8em' }} />
              <Chip label={releasedLoansCount} sx={{ backgroundColor: '#023e8a', color: '#ffffff', fontWeight: 'bold', fontSize: '0.75em' }} />
            </ListItemButton>
  
            {/* Paid Loans */}
            <ListItemButton 
              sx={{
                borderRadius: '8px',
                pl: 4,
                padding: '6px 12px',
                fontSize: '0.8em',
                backgroundColor: currentPath === '/loans/Paid' ? '#b2dfdb' : 'transparent',
                '&:hover': { backgroundColor: '#b2dfdb' },
              }}
              onClick={() => handleNavigation('/loans/Paid')}>
              <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
                <CreditScoreIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText primary="Paid Loans" sx={{ fontSize: '0.8em' }} />
            </ListItemButton>
          </List>
        </Collapse>
  
        {/* Other Items */}
        <ListItemButton 
          onClick={() => handleNavigation('/loanApplication')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',
            fontSize: '0.8em',
            '&:hover': { backgroundColor: '#b2dfdb' },
            backgroundColor: currentPath === '/loanApplication' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <AddCardIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Loan Application" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
  
        <ListItemButton 
          onClick={() => handleNavigation('/transactionhistory')}
          sx={{
            borderRadius: '8px',
            padding: '6px 12px',
            fontSize: '0.8em',
            '&:hover': { backgroundColor: '#b2dfdb' },
            backgroundColor: currentPath === '/transactionhistory' ? '#b2dfdb' : 'transparent',
          }}>
          <ListItemIcon sx={{ minWidth: 35 }}> {/* Smaller icon size */}
            <ReceiptLongIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText primary="Transaction History" sx={{ fontSize: '0.8em' }} />
        </ListItemButton>
      </List>
      <Box sx={{ display: 'flex', gap: 2, mt: 'auto', flexDirection: 'column' }}>
        <TextField id="outlined-basic" label="Available Balance" variant="outlined" size="small" />
        <TextField id="outlined-basic" label="Used Balance" variant="outlined" size="small" />
      <Box sx={{ display: 'flex', justifyContent: 'center' }}>
        <Button variant="contained" color="primary" size="small" onClick={handleClickOpen}>
           Update Balance
        </Button>
        <Dialog
        open={open}
        TransitionComponent={Transition}
        keepMounted
        onClose={handleClose}
        aria-describedby="alert-dialog-slide-description"
      >
        <DialogTitle>{"Use Google's location service?"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-slide-description">
            Let Google help apps determine location. This means sending anonymous
            location data to Google, even when no apps are running.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Disagree</Button>
          <Button onClick={handleClose}>Agree</Button>
        </DialogActions>
      </Dialog>
      </Box>
      </Box>
      <Box sx={{ mt: 'auto', mb: 2 }}>
        <Box
          sx={{
            borderRadius: '12px',
            padding: '16px',
            backgroundColor: '#FCFCFF',
            boxShadow: '0 4px 8px rgba(0,0,0,0.08)',
            transition: 'all 0.2s ease-in-out',
            display: 'flex',
            alignItems: 'center', // Aligns content horizontally
            gap: 2,
            justifyContent: 'space-between',
          }}
        >
          <Box>
            <Typography
              variant="subtitle1"
              sx={{
                fontSize: '0.8rem',
                fontWeight: 600,
                color: '#2c3e50',
              }}
            >
              {name}
            </Typography>
            <Typography
              variant="body2"
              sx={{
                opacity: 0.7,
                fontSize: '0.8rem',
                fontWeight: 500,
              }}
            >
              {email}
            </Typography>
          </Box>
          <Box>
            <LogoutRoundedIcon sx={{ color: '#d90429', fontSize: '1.5rem' }} />
          </Box>
        </Box>
      </Box>

    </Box>
  );
  

  return (
    <ThemeProvider theme={theme}>
      <Box sx={{ display: 'flex' }}>
        <CssBaseline />
        <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
          <Toolbar>
            {isMobile && (
              <IconButton edge="start" color="inherit" onClick={handleDrawerToggle} sx={{ mr: 2 }}>
                <MenuIcon />
              </IconButton>
            )}
            <Typography variant="h6" noWrap component="div" sx={{ display: 'flex', alignItems: 'center', fontWeight: 'bold' }}>
              <img src={Neeco} alt="Neeco Logo" style={{ width: '30px', height: 'auto', marginRight: '10px' }} />
               NEECO II AREA 1
            </Typography>
          </Toolbar>
        </AppBar>

        <Drawer
          variant={isMobile ? "temporary" : "permanent"}
          open={isMobile ? mobileOpen : true}
          onClose={handleDrawerToggle}
          sx={{
            width: drawerWidth,
            flexShrink: 0,
            '& .MuiDrawer-paper': { width: drawerWidth, boxSizing: 'border-box' },
          }}
        >
          <Toolbar />
          {drawerContent}
        </Drawer>

        <Main
          sx={{
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            width: '100%', // Makes sure it takes full width
            padding: (theme) => theme.spacing(3),
            scrollbarWidth: 'none',
          }}
        >
          <Toolbar />
          <Box
            sx={{
              width: '100%',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              flexGrow: 1,
            }}
          >
            {currentPage}
          </Box>
        </Main>
      </Box>
    </ThemeProvider>
  );
};

export default DashboardLayoutBasic;
